from pathlib import Path
import argparse
import subprocess
import os
import shutil

WINDOWS_LINE_ENDING = "\r\n"
UNIX_LINE_ENDING = "\n"


def cleanup_input_file(input_fname: str):
    """Perform the follwing cleanup:
       * Remove byte order marks (BOM)
       * Replace all Windows line endings with Unix line endings

    Args:
        input_fname (str): file name to cleanup
    """
    # Make sure all input files have LF line ending
    with open(input_fname, mode="r", encoding="utf-8-sig") as file:
        lines = file.read()
        lines = lines.replace(WINDOWS_LINE_ENDING, UNIX_LINE_ENDING)

    # Remove BOMs
    with open(input_fname, mode="w", encoding="utf-8") as file:
        file.write(lines)


def generate_svd_file(input_filename: str, output_filename: str):
    """Generate SVD file for device family using tixml2svd

       This is intended to run on TI style XML files as taken from CCS.
       The files in this repo are hand maintained to reduce the duplication
       of the PACs. Many devices in the LPRF family are similar and thus
       each device does not need its own PAC.

       Instead, the top level XML files (those under devices folder) are made
       to cover multiple devices and are organized similar to TI's driverlib format.

       Thses top level files do not contain any peripheral definitions. That is to be
       found under modules folder.

       Finally, the tixml2svd comment is removed because svd2rust doesn't like it.
       Sorry dhoove!


    Args:
        input_filename (str): Name of top level xml file that describes a device
        output_filename (str): Name of output SVD file
    """
    # Generate SVD files using tixml2svd
    with open(output_filename.as_posix(), mode="w") as file:
        contents = subprocess.check_output(
            ["tixml2svd", "-z", "-i", input_filename], text=True
        ).replace(
            "<!-- Created by tixml2svd; https://github.com/dhoove/tixml2svd -->\n", ""
        )
        file.write(contents)


def svd2rust(svd_file_path: str):
    """Run svd2rust to generate PAC from SVD file that was generated by the previous step
       Follow steps here: https://docs.rs/svd2rust/latest/svd2rust/

       Will also run cargo init if not already done

       This function expects to be called from the PAC's directory

    Args:
        svd_file_path (str): Absolute path to SVD file
    """
    subprocess.run(["cargo", "init", "--lib", "--vcs=none"])

    # Generate the PAC using SVD to Rust.
    subprocess.run(["svd2rust", "-i", Path(svd_file_path).as_posix(), "-o", "."])

    # Remove generated src dir, we will make it again later
    shutil.rmtree("./src")

    # Run form on generated output
    subprocess.run(["form", "-i", "lib.rs", "-o", "src"])
    # Delete unnecessary files
    Path("./lib.rs").unlink()
    # Run code fomatting on generated output
    subprocess.run(["cargo", "fmt"])


def patch_vectors(pac_path: str, int_rs_path: str, device_x_path: str):
    """Patch the interrupt vector defintions in the generated PAC

       The TI XML doesn't contain definitions of the interrupt vector table
       So this is also missing from the generated SVDs.

       This repo contains handmade vector table definitions in rust.
       This function will patch the generated code with the hand created (correct)
       copies

       Note: This function expects to be run in the directory of the PAC

    Args:
        lib_rs_path (str): Path to lib.rs file to patch
        int_rs_path (str): Path to interrupt definition file written in rust
    """
    lib_rs_path = Path("src/lib.rs").as_posix()
    with open(lib_rs_path, mode="r+") as lib_file, open(int_rs_path, mode="r") as ints:
        # There are two parts of the input files. The C declarations and the rust based vector table
        # These are delimited by `}` and two newlines.
        extern_string = ints.read().split("}\n\n")
        lib_string = lib_file.read()

        # Replace the generated (empty) extern C section
        lib_string = lib_string.replace('extern "C" {}\n', extern_string[0] + "}\n")

        # Replace the empty generated vector table
        lib_string = lib_string.replace(
            "pub static __INTERRUPTS: [Vector; 0] = [];", extern_string[1]
        )

        # Write the contents back to lib.rs
        lib_file.seek(0)
        lib_file.write(lib_string)
        lib_file.truncate()


    shutil.copy(device_x_path, os.curdir)
    device_x_stem = Path(device_x_path).name
    os.rename(device_x_stem, "device.x")

def app():
    """This function contains the main logic of the program. It does the following
    1. Define and parse arguments
    2. Discover devices to operate on based on XML files found in input folder
    3. Cleanup the input files
    4. Generate SVD files using tixml2svd
    5. Generate Rust Peripheral Access Crates (PAC)s using svd2rust
    6. Patch crates to replace missing definitions
    """
    parser = argparse.ArgumentParser(
        description="Generate Rust Peripheral Access Crates for TI's LPRF Devices"
    )
    parser.add_argument("input", help="Folder containing CCS device xml")
    parser.add_argument(
        "-osvds",
        "--output_folder_svds",
        dest="output_folder_svds",
        help="Folder to store SVD files in",
    )
    parser.add_argument(
        "-opacs",
        "--output_folder_pacs",
        dest="output_folder_pacs",
        help="Folder to store PAC files in",
    )

    args = parser.parse_args()

    # Find all device families that have XML files
    input_path = Path(args.input)
    devs = [(path.name, path.stem) for path in list(input_path.glob("*.xml"))]

    for dev in devs:
        # This could be more readable, NB! its tied to the list comprehension above
        device_name = dev[1]
        device_family_file = dev[0]
        output_svd_fname = Path(f"{args.output_folder_svds}/{device_name}.svd")
        input_xml_fname = f"{input_path / device_family_file}"
        

        # Cleanup the files from CCS as described in the tixml2svd docs
        cleanup_input_file(input_xml_fname)

        # Generate SVD files using tixml2svd
        generate_svd_file(input_xml_fname, output_svd_fname)

        pac_directory = f"{args.output_folder_pacs}/{device_name}"

        # Create a directory for the PAC if it doesn't already exist
        if not os.path.exists(pac_directory):
            os.mkdir(pac_directory)

        # Store the current directory so we can change back to it later
        old_path = os.getcwd()
        os.chdir(pac_directory)

        # Generate PAC
        svd_path = Path(old_path / output_svd_fname).as_posix()
        svd2rust(svd_path)

        # TI's XMLs don't contain interrupt vector table defintions
        # Patch the generated rust files
        int_path = Path(f"{old_path}/{args.input}/{device_name}_ints.rs").as_posix()
        device_x_path = Path(f"{old_path}/{args.input}/{device_name}_device.x").as_posix()
        patch_vectors(pac_directory, int_path, device_x_path)

        # Change back to the original directory, preserving state
        os.chdir(old_path)


if __name__ == "__main__":
    app()
