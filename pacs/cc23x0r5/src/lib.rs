#![doc = "Peripheral access API for CC2340R5 microcontrollers (generated using svd2rust v0.33.1 ( ))\n\nYou can find an overview of the generated API [here].\n\nAPI features to be included in the [next]
svd2rust release can be generated by cloning the svd2rust [repository], checking out the above commit, and running `cargo doc --open`.\n\n[here]: https://docs.rs/svd2rust/0.33.1/svd2rust/#peripheral-api\n[next]: https://github.com/rust-embedded/svd2rust/blob/master/CHANGELOG.md#unreleased\n[repository]: https://github.com/rust-embedded/svd2rust"]
#![allow(non_camel_case_types)]
#![allow(non_snake_case)]
#![no_std]
use core::marker::PhantomData;
use core::ops::Deref;
#[doc = r"Number available in the NVIC for configuring priority"]
pub const NVIC_PRIO_BITS: u8 = 3;
#[allow(unused_imports)]
use generic::*;
#[doc = r"Common register and bit access and modify traits"]
pub mod generic;
#[cfg(feature = "rt")]
extern "C" {
    fn INT_CPUIRQ0();
    fn INT_CPUIRQ1();
    fn INT_CPUIRQ2();
    fn INT_CPUIRQ3();
    fn INT_CPUIRQ4();
    fn INT_GPIO_COMB();
    fn INT_LRFD_IRQ0();
    fn INT_LRFD_IRQ1();
    fn INT_DMA_DONE_COMB();
    fn INT_AES_COMB();
    fn INT_SPI0_COMB();
    fn INT_UART0_COMB();
    fn INT_I2C0_IRQ();
    fn INT_LGPT0_COMB();
    fn INT_LGPT1_COMB();
    fn INT_ADC_COMB();
    fn INT_CPUIRQ16();
    fn INT_LGPT2_COMB();
    fn INT_LGPT3_COMB();
}
#[doc(hidden)]
#[repr(C)]
pub union Vector {
    _handler: unsafe extern "C" fn(),
    _reserved: u32,
}
#[cfg(feature = "rt")]
#[doc(hidden)]
#[link_section = ".vector_table.interrupts"]
#[no_mangle]
pub static __INTERRUPTS: [Vector; 19] = [
    Vector { _handler: INT_CPUIRQ0 },
    Vector { _handler: INT_CPUIRQ1 },
    Vector { _handler: INT_CPUIRQ2 },
    Vector { _handler: INT_CPUIRQ3 },
    Vector { _handler: INT_CPUIRQ4 },
    Vector { _handler: INT_GPIO_COMB },
    Vector { _handler: INT_LRFD_IRQ0 },
    Vector { _handler: INT_LRFD_IRQ1 },
    Vector { _handler: INT_DMA_DONE_COMB },
    Vector { _handler: INT_AES_COMB },
    Vector { _handler: INT_SPI0_COMB },
    Vector { _handler: INT_UART0_COMB },
    Vector { _handler: INT_I2C0_IRQ },
    Vector { _handler: INT_LGPT0_COMB },
    Vector { _handler: INT_LGPT1_COMB },
    Vector { _handler: INT_ADC_COMB },
    Vector { _handler: INT_CPUIRQ16 },
    Vector { _handler: INT_LGPT2_COMB },
    Vector { _handler: INT_LGPT3_COMB }
];

#[doc = r"Enumeration of all the interrupts."]
#[derive(Copy, Clone, Debug, PartialEq, Eq)]
pub enum Interrupt {
    INT_CPUIRQ0 = 0,
    INT_CPUIRQ1 = 1,
    INT_CPUIRQ2 = 2,
    INT_CPUIRQ3 = 3,
    INT_CPUIRQ4 = 4,
    INT_GPIO_COMB = 5,
    INT_LRFD_IRQ0 = 6,
    INT_LRFD_IRQ1 = 7,
    INT_DMA_DONE_COMB = 8,
    INT_AES_COMB = 9,
    INT_SPI0_COMB = 10,
    INT_UART0_COMB = 11,
    INT_I2C0_IRQ = 12,
    INT_LGPT0_COMB = 13,
    INT_LGPT1_COMB = 14,
    INT_ADC_COMB = 15,
    INT_CPUIRQ16 = 16,
    INT_LGPT2_COMB = 17,
    INT_LGPT3_COMB = 18,
}

unsafe impl cortex_m::interrupt::InterruptNumber for Interrupt {
    #[inline(always)]
    fn number(self) -> u16 {
        self as u16
    }
}
#[doc = "This component is the Power Management controller. Together with the System Controller, it controls system resets and the power states of the device."]
pub struct Pmctl {
    _marker: PhantomData<*const ()>,
}
unsafe impl Send for Pmctl {}
impl Pmctl {
    #[doc = r"Pointer to the register block"]
    pub const PTR: *const pmctl::RegisterBlock = 0x4000_0000 as *const _;
    #[doc = r"Return the pointer to the register block"]
    #[inline(always)]
    pub const fn ptr() -> *const pmctl::RegisterBlock {
        Self::PTR
    }
    #[doc = r" Steal an instance of this peripheral"]
    #[doc = r""]
    #[doc = r" # Safety"]
    #[doc = r""]
    #[doc = r" Ensure that the new instance of the peripheral cannot be used in a way"]
    #[doc = r" that may race with any existing instances, for example by only"]
    #[doc = r" accessing read-only or write-only registers, or by consuming the"]
    #[doc = r" original peripheral and using critical sections to coordinate"]
    #[doc = r" access between multiple new instances."]
    #[doc = r""]
    #[doc = r" Additionally, other software such as HALs may rely on only one"]
    #[doc = r" peripheral instance existing to ensure memory safety; ensure"]
    #[doc = r" no stolen instances are passed to such software."]
    pub unsafe fn steal() -> Self {
        Self {
            _marker: PhantomData,
        }
    }
}
impl Deref for Pmctl {
    type Target = pmctl::RegisterBlock;
    #[inline(always)]
    fn deref(&self) -> &Self::Target {
        unsafe { &*Self::PTR }
    }
}
impl core::fmt::Debug for Pmctl {
    fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
        f.debug_struct("Pmctl").finish()
    }
}
#[doc = "This component is the Power Management controller. Together with the System Controller, it controls system resets and the power states of the device."]
pub mod pmctl;
#[doc = "Clock Controller"]
pub struct Ckmd {
    _marker: PhantomData<*const ()>,
}
unsafe impl Send for Ckmd {}
impl Ckmd {
    #[doc = r"Pointer to the register block"]
    pub const PTR: *const ckmd::RegisterBlock = 0x4000_1000 as *const _;
    #[doc = r"Return the pointer to the register block"]
    #[inline(always)]
    pub const fn ptr() -> *const ckmd::RegisterBlock {
        Self::PTR
    }
    #[doc = r" Steal an instance of this peripheral"]
    #[doc = r""]
    #[doc = r" # Safety"]
    #[doc = r""]
    #[doc = r" Ensure that the new instance of the peripheral cannot be used in a way"]
    #[doc = r" that may race with any existing instances, for example by only"]
    #[doc = r" accessing read-only or write-only registers, or by consuming the"]
    #[doc = r" original peripheral and using critical sections to coordinate"]
    #[doc = r" access between multiple new instances."]
    #[doc = r""]
    #[doc = r" Additionally, other software such as HALs may rely on only one"]
    #[doc = r" peripheral instance existing to ensure memory safety; ensure"]
    #[doc = r" no stolen instances are passed to such software."]
    pub unsafe fn steal() -> Self {
        Self {
            _marker: PhantomData,
        }
    }
}
impl Deref for Ckmd {
    type Target = ckmd::RegisterBlock;
    #[inline(always)]
    fn deref(&self) -> &Self::Target {
        unsafe { &*Self::PTR }
    }
}
impl core::fmt::Debug for Ckmd {
    fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
        f.debug_struct("Ckmd").finish()
    }
}
#[doc = "Clock Controller"]
pub mod ckmd;
#[doc = "ULL Real Time Clock module RTC includes 2 channels. - Channel 0 is a compare channel - Channel 1 is a capture channel"]
pub struct Rtc {
    _marker: PhantomData<*const ()>,
}
unsafe impl Send for Rtc {}
impl Rtc {
    #[doc = r"Pointer to the register block"]
    pub const PTR: *const rtc::RegisterBlock = 0x4000_2000 as *const _;
    #[doc = r"Return the pointer to the register block"]
    #[inline(always)]
    pub const fn ptr() -> *const rtc::RegisterBlock {
        Self::PTR
    }
    #[doc = r" Steal an instance of this peripheral"]
    #[doc = r""]
    #[doc = r" # Safety"]
    #[doc = r""]
    #[doc = r" Ensure that the new instance of the peripheral cannot be used in a way"]
    #[doc = r" that may race with any existing instances, for example by only"]
    #[doc = r" accessing read-only or write-only registers, or by consuming the"]
    #[doc = r" original peripheral and using critical sections to coordinate"]
    #[doc = r" access between multiple new instances."]
    #[doc = r""]
    #[doc = r" Additionally, other software such as HALs may rely on only one"]
    #[doc = r" peripheral instance existing to ensure memory safety; ensure"]
    #[doc = r" no stolen instances are passed to such software."]
    pub unsafe fn steal() -> Self {
        Self {
            _marker: PhantomData,
        }
    }
}
impl Deref for Rtc {
    type Target = rtc::RegisterBlock;
    #[inline(always)]
    fn deref(&self) -> &Self::Target {
        unsafe { &*Self::PTR }
    }
}
impl core::fmt::Debug for Rtc {
    fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
        f.debug_struct("Rtc").finish()
    }
}
#[doc = "ULL Real Time Clock module RTC includes 2 channels. - Channel 0 is a compare channel - Channel 1 is a capture channel"]
pub mod rtc;
#[doc = "ULL IOC"]
pub struct Ioc {
    _marker: PhantomData<*const ()>,
}
unsafe impl Send for Ioc {}
impl Ioc {
    #[doc = r"Pointer to the register block"]
    pub const PTR: *const ioc::RegisterBlock = 0x4000_3000 as *const _;
    #[doc = r"Return the pointer to the register block"]
    #[inline(always)]
    pub const fn ptr() -> *const ioc::RegisterBlock {
        Self::PTR
    }
    #[doc = r" Steal an instance of this peripheral"]
    #[doc = r""]
    #[doc = r" # Safety"]
    #[doc = r""]
    #[doc = r" Ensure that the new instance of the peripheral cannot be used in a way"]
    #[doc = r" that may race with any existing instances, for example by only"]
    #[doc = r" accessing read-only or write-only registers, or by consuming the"]
    #[doc = r" original peripheral and using critical sections to coordinate"]
    #[doc = r" access between multiple new instances."]
    #[doc = r""]
    #[doc = r" Additionally, other software such as HALs may rely on only one"]
    #[doc = r" peripheral instance existing to ensure memory safety; ensure"]
    #[doc = r" no stolen instances are passed to such software."]
    pub unsafe fn steal() -> Self {
        Self {
            _marker: PhantomData,
        }
    }
}
impl Deref for Ioc {
    type Target = ioc::RegisterBlock;
    #[inline(always)]
    fn deref(&self) -> &Self::Target {
        unsafe { &*Self::PTR }
    }
}
impl core::fmt::Debug for Ioc {
    fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
        f.debug_struct("Ioc").finish()
    }
}
#[doc = "ULL IOC"]
pub mod ioc;
#[doc = "This is top module of SYS0 for LOKI"]
pub struct Sys0 {
    _marker: PhantomData<*const ()>,
}
unsafe impl Send for Sys0 {}
impl Sys0 {
    #[doc = r"Pointer to the register block"]
    pub const PTR: *const sys0::RegisterBlock = 0x4000_4000 as *const _;
    #[doc = r"Return the pointer to the register block"]
    #[inline(always)]
    pub const fn ptr() -> *const sys0::RegisterBlock {
        Self::PTR
    }
    #[doc = r" Steal an instance of this peripheral"]
    #[doc = r""]
    #[doc = r" # Safety"]
    #[doc = r""]
    #[doc = r" Ensure that the new instance of the peripheral cannot be used in a way"]
    #[doc = r" that may race with any existing instances, for example by only"]
    #[doc = r" accessing read-only or write-only registers, or by consuming the"]
    #[doc = r" original peripheral and using critical sections to coordinate"]
    #[doc = r" access between multiple new instances."]
    #[doc = r""]
    #[doc = r" Additionally, other software such as HALs may rely on only one"]
    #[doc = r" peripheral instance existing to ensure memory safety; ensure"]
    #[doc = r" no stolen instances are passed to such software."]
    pub unsafe fn steal() -> Self {
        Self {
            _marker: PhantomData,
        }
    }
}
impl Deref for Sys0 {
    type Target = sys0::RegisterBlock;
    #[inline(always)]
    fn deref(&self) -> &Self::Target {
        unsafe { &*Self::PTR }
    }
}
impl core::fmt::Debug for Sys0 {
    fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
        f.debug_struct("Sys0").finish()
    }
}
#[doc = "This is top module of SYS0 for LOKI"]
pub mod sys0;
#[doc = "This is top module of ULL Event Fabric"]
pub struct Evtull {
    _marker: PhantomData<*const ()>,
}
unsafe impl Send for Evtull {}
impl Evtull {
    #[doc = r"Pointer to the register block"]
    pub const PTR: *const evtull::RegisterBlock = 0x4000_5000 as *const _;
    #[doc = r"Return the pointer to the register block"]
    #[inline(always)]
    pub const fn ptr() -> *const evtull::RegisterBlock {
        Self::PTR
    }
    #[doc = r" Steal an instance of this peripheral"]
    #[doc = r""]
    #[doc = r" # Safety"]
    #[doc = r""]
    #[doc = r" Ensure that the new instance of the peripheral cannot be used in a way"]
    #[doc = r" that may race with any existing instances, for example by only"]
    #[doc = r" accessing read-only or write-only registers, or by consuming the"]
    #[doc = r" original peripheral and using critical sections to coordinate"]
    #[doc = r" access between multiple new instances."]
    #[doc = r""]
    #[doc = r" Additionally, other software such as HALs may rely on only one"]
    #[doc = r" peripheral instance existing to ensure memory safety; ensure"]
    #[doc = r" no stolen instances are passed to such software."]
    pub unsafe fn steal() -> Self {
        Self {
            _marker: PhantomData,
        }
    }
}
impl Deref for Evtull {
    type Target = evtull::RegisterBlock;
    #[inline(always)]
    fn deref(&self) -> &Self::Target {
        unsafe { &*Self::PTR }
    }
}
impl core::fmt::Debug for Evtull {
    fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
        f.debug_struct("Evtull").finish()
    }
}
#[doc = "This is top module of ULL Event Fabric"]
pub mod evtull;
#[doc = "PMUD"]
pub struct Pmud {
    _marker: PhantomData<*const ()>,
}
unsafe impl Send for Pmud {}
impl Pmud {
    #[doc = r"Pointer to the register block"]
    pub const PTR: *const pmud::RegisterBlock = 0x4000_6000 as *const _;
    #[doc = r"Return the pointer to the register block"]
    #[inline(always)]
    pub const fn ptr() -> *const pmud::RegisterBlock {
        Self::PTR
    }
    #[doc = r" Steal an instance of this peripheral"]
    #[doc = r""]
    #[doc = r" # Safety"]
    #[doc = r""]
    #[doc = r" Ensure that the new instance of the peripheral cannot be used in a way"]
    #[doc = r" that may race with any existing instances, for example by only"]
    #[doc = r" accessing read-only or write-only registers, or by consuming the"]
    #[doc = r" original peripheral and using critical sections to coordinate"]
    #[doc = r" access between multiple new instances."]
    #[doc = r""]
    #[doc = r" Additionally, other software such as HALs may rely on only one"]
    #[doc = r" peripheral instance existing to ensure memory safety; ensure"]
    #[doc = r" no stolen instances are passed to such software."]
    pub unsafe fn steal() -> Self {
        Self {
            _marker: PhantomData,
        }
    }
}
impl Deref for Pmud {
    type Target = pmud::RegisterBlock;
    #[inline(always)]
    fn deref(&self) -> &Self::Target {
        unsafe { &*Self::PTR }
    }
}
impl core::fmt::Debug for Pmud {
    fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
        f.debug_struct("Pmud").finish()
    }
}
#[doc = "PMUD"]
pub mod pmud;
#[doc = "DBGSS"]
pub struct Dbgss {
    _marker: PhantomData<*const ()>,
}
unsafe impl Send for Dbgss {}
impl Dbgss {
    #[doc = r"Pointer to the register block"]
    pub const PTR: *const dbgss::RegisterBlock = 0x4000_f000 as *const _;
    #[doc = r"Return the pointer to the register block"]
    #[inline(always)]
    pub const fn ptr() -> *const dbgss::RegisterBlock {
        Self::PTR
    }
    #[doc = r" Steal an instance of this peripheral"]
    #[doc = r""]
    #[doc = r" # Safety"]
    #[doc = r""]
    #[doc = r" Ensure that the new instance of the peripheral cannot be used in a way"]
    #[doc = r" that may race with any existing instances, for example by only"]
    #[doc = r" accessing read-only or write-only registers, or by consuming the"]
    #[doc = r" original peripheral and using critical sections to coordinate"]
    #[doc = r" access between multiple new instances."]
    #[doc = r""]
    #[doc = r" Additionally, other software such as HALs may rely on only one"]
    #[doc = r" peripheral instance existing to ensure memory safety; ensure"]
    #[doc = r" no stolen instances are passed to such software."]
    pub unsafe fn steal() -> Self {
        Self {
            _marker: PhantomData,
        }
    }
}
impl Deref for Dbgss {
    type Target = dbgss::RegisterBlock;
    #[inline(always)]
    fn deref(&self) -> &Self::Target {
        unsafe { &*Self::PTR }
    }
}
impl core::fmt::Debug for Dbgss {
    fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
        f.debug_struct("Dbgss").finish()
    }
}
#[doc = "DBGSS"]
pub mod dbgss;
#[doc = "This component is the clock controller. Here SW can turn on and off IP clocks and read IP and system clock status."]
pub struct Clkctl {
    _marker: PhantomData<*const ()>,
}
unsafe impl Send for Clkctl {}
impl Clkctl {
    #[doc = r"Pointer to the register block"]
    pub const PTR: *const clkctl::RegisterBlock = 0x4002_0000 as *const _;
    #[doc = r"Return the pointer to the register block"]
    #[inline(always)]
    pub const fn ptr() -> *const clkctl::RegisterBlock {
        Self::PTR
    }
    #[doc = r" Steal an instance of this peripheral"]
    #[doc = r""]
    #[doc = r" # Safety"]
    #[doc = r""]
    #[doc = r" Ensure that the new instance of the peripheral cannot be used in a way"]
    #[doc = r" that may race with any existing instances, for example by only"]
    #[doc = r" accessing read-only or write-only registers, or by consuming the"]
    #[doc = r" original peripheral and using critical sections to coordinate"]
    #[doc = r" access between multiple new instances."]
    #[doc = r""]
    #[doc = r" Additionally, other software such as HALs may rely on only one"]
    #[doc = r" peripheral instance existing to ensure memory safety; ensure"]
    #[doc = r" no stolen instances are passed to such software."]
    pub unsafe fn steal() -> Self {
        Self {
            _marker: PhantomData,
        }
    }
}
impl Deref for Clkctl {
    type Target = clkctl::RegisterBlock;
    #[inline(always)]
    fn deref(&self) -> &Self::Target {
        unsafe { &*Self::PTR }
    }
}
impl core::fmt::Debug for Clkctl {
    fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
        f.debug_struct("Clkctl").finish()
    }
}
#[doc = "This component is the clock controller. Here SW can turn on and off IP clocks and read IP and system clock status."]
pub mod clkctl;
#[doc = "FLASH"]
pub struct Flash {
    _marker: PhantomData<*const ()>,
}
unsafe impl Send for Flash {}
impl Flash {
    #[doc = r"Pointer to the register block"]
    pub const PTR: *const flash::RegisterBlock = 0x4002_1000 as *const _;
    #[doc = r"Return the pointer to the register block"]
    #[inline(always)]
    pub const fn ptr() -> *const flash::RegisterBlock {
        Self::PTR
    }
    #[doc = r" Steal an instance of this peripheral"]
    #[doc = r""]
    #[doc = r" # Safety"]
    #[doc = r""]
    #[doc = r" Ensure that the new instance of the peripheral cannot be used in a way"]
    #[doc = r" that may race with any existing instances, for example by only"]
    #[doc = r" accessing read-only or write-only registers, or by consuming the"]
    #[doc = r" original peripheral and using critical sections to coordinate"]
    #[doc = r" access between multiple new instances."]
    #[doc = r""]
    #[doc = r" Additionally, other software such as HALs may rely on only one"]
    #[doc = r" peripheral instance existing to ensure memory safety; ensure"]
    #[doc = r" no stolen instances are passed to such software."]
    pub unsafe fn steal() -> Self {
        Self {
            _marker: PhantomData,
        }
    }
}
impl Deref for Flash {
    type Target = flash::RegisterBlock;
    #[inline(always)]
    fn deref(&self) -> &Self::Target {
        unsafe { &*Self::PTR }
    }
}
impl core::fmt::Debug for Flash {
    fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
        f.debug_struct("Flash").finish()
    }
}
#[doc = "FLASH"]
pub mod flash;
#[doc = "SVT System Timer Module"]
pub struct Systim {
    _marker: PhantomData<*const ()>,
}
unsafe impl Send for Systim {}
impl Systim {
    #[doc = r"Pointer to the register block"]
    pub const PTR: *const systim::RegisterBlock = 0x4002_2000 as *const _;
    #[doc = r"Return the pointer to the register block"]
    #[inline(always)]
    pub const fn ptr() -> *const systim::RegisterBlock {
        Self::PTR
    }
    #[doc = r" Steal an instance of this peripheral"]
    #[doc = r""]
    #[doc = r" # Safety"]
    #[doc = r""]
    #[doc = r" Ensure that the new instance of the peripheral cannot be used in a way"]
    #[doc = r" that may race with any existing instances, for example by only"]
    #[doc = r" accessing read-only or write-only registers, or by consuming the"]
    #[doc = r" original peripheral and using critical sections to coordinate"]
    #[doc = r" access between multiple new instances."]
    #[doc = r""]
    #[doc = r" Additionally, other software such as HALs may rely on only one"]
    #[doc = r" peripheral instance existing to ensure memory safety; ensure"]
    #[doc = r" no stolen instances are passed to such software."]
    pub unsafe fn steal() -> Self {
        Self {
            _marker: PhantomData,
        }
    }
}
impl Deref for Systim {
    type Target = systim::RegisterBlock;
    #[inline(always)]
    fn deref(&self) -> &Self::Target {
        unsafe { &*Self::PTR }
    }
}
impl core::fmt::Debug for Systim {
    fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
        f.debug_struct("Systim").finish()
    }
}
#[doc = "SVT System Timer Module"]
pub mod systim;
#[doc = "MCU GPIO - I/F for controlling and reading IO status and IO event status"]
pub struct Gpio {
    _marker: PhantomData<*const ()>,
}
unsafe impl Send for Gpio {}
impl Gpio {
    #[doc = r"Pointer to the register block"]
    pub const PTR: *const gpio::RegisterBlock = 0x4002_3000 as *const _;
    #[doc = r"Return the pointer to the register block"]
    #[inline(always)]
    pub const fn ptr() -> *const gpio::RegisterBlock {
        Self::PTR
    }
    #[doc = r" Steal an instance of this peripheral"]
    #[doc = r""]
    #[doc = r" # Safety"]
    #[doc = r""]
    #[doc = r" Ensure that the new instance of the peripheral cannot be used in a way"]
    #[doc = r" that may race with any existing instances, for example by only"]
    #[doc = r" accessing read-only or write-only registers, or by consuming the"]
    #[doc = r" original peripheral and using critical sections to coordinate"]
    #[doc = r" access between multiple new instances."]
    #[doc = r""]
    #[doc = r" Additionally, other software such as HALs may rely on only one"]
    #[doc = r" peripheral instance existing to ensure memory safety; ensure"]
    #[doc = r" no stolen instances are passed to such software."]
    pub unsafe fn steal() -> Self {
        Self {
            _marker: PhantomData,
        }
    }
}
impl Deref for Gpio {
    type Target = gpio::RegisterBlock;
    #[inline(always)]
    fn deref(&self) -> &Self::Target {
        unsafe { &*Self::PTR }
    }
}
impl core::fmt::Debug for Gpio {
    fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
        f.debug_struct("Gpio").finish()
    }
}
#[doc = "MCU GPIO - I/F for controlling and reading IO status and IO event status"]
pub mod gpio;
#[doc = "Loki VIMS module toplevel"]
pub struct Vims {
    _marker: PhantomData<*const ()>,
}
unsafe impl Send for Vims {}
impl Vims {
    #[doc = r"Pointer to the register block"]
    pub const PTR: *const vims::RegisterBlock = 0x4002_4000 as *const _;
    #[doc = r"Return the pointer to the register block"]
    #[inline(always)]
    pub const fn ptr() -> *const vims::RegisterBlock {
        Self::PTR
    }
    #[doc = r" Steal an instance of this peripheral"]
    #[doc = r""]
    #[doc = r" # Safety"]
    #[doc = r""]
    #[doc = r" Ensure that the new instance of the peripheral cannot be used in a way"]
    #[doc = r" that may race with any existing instances, for example by only"]
    #[doc = r" accessing read-only or write-only registers, or by consuming the"]
    #[doc = r" original peripheral and using critical sections to coordinate"]
    #[doc = r" access between multiple new instances."]
    #[doc = r""]
    #[doc = r" Additionally, other software such as HALs may rely on only one"]
    #[doc = r" peripheral instance existing to ensure memory safety; ensure"]
    #[doc = r" no stolen instances are passed to such software."]
    pub unsafe fn steal() -> Self {
        Self {
            _marker: PhantomData,
        }
    }
}
impl Deref for Vims {
    type Target = vims::RegisterBlock;
    #[inline(always)]
    fn deref(&self) -> &Self::Target {
        unsafe { &*Self::PTR }
    }
}
impl core::fmt::Debug for Vims {
    fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
        f.debug_struct("Vims").finish()
    }
}
#[doc = "Loki VIMS module toplevel"]
pub mod vims;
#[doc = "This is top module of SVT Event Fabric"]
pub struct Evtsvt {
    _marker: PhantomData<*const ()>,
}
unsafe impl Send for Evtsvt {}
impl Evtsvt {
    #[doc = r"Pointer to the register block"]
    pub const PTR: *const evtsvt::RegisterBlock = 0x4002_5000 as *const _;
    #[doc = r"Return the pointer to the register block"]
    #[inline(always)]
    pub const fn ptr() -> *const evtsvt::RegisterBlock {
        Self::PTR
    }
    #[doc = r" Steal an instance of this peripheral"]
    #[doc = r""]
    #[doc = r" # Safety"]
    #[doc = r""]
    #[doc = r" Ensure that the new instance of the peripheral cannot be used in a way"]
    #[doc = r" that may race with any existing instances, for example by only"]
    #[doc = r" accessing read-only or write-only registers, or by consuming the"]
    #[doc = r" original peripheral and using critical sections to coordinate"]
    #[doc = r" access between multiple new instances."]
    #[doc = r""]
    #[doc = r" Additionally, other software such as HALs may rely on only one"]
    #[doc = r" peripheral instance existing to ensure memory safety; ensure"]
    #[doc = r" no stolen instances are passed to such software."]
    pub unsafe fn steal() -> Self {
        Self {
            _marker: PhantomData,
        }
    }
}
impl Deref for Evtsvt {
    type Target = evtsvt::RegisterBlock;
    #[inline(always)]
    fn deref(&self) -> &Self::Target {
        unsafe { &*Self::PTR }
    }
}
impl core::fmt::Debug for Evtsvt {
    fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
        f.debug_struct("Evtsvt").finish()
    }
}
#[doc = "This is top module of SVT Event Fabric"]
pub mod evtsvt;
#[doc = "ARM Micro Direct Memory Access Controller"]
pub struct Dma {
    _marker: PhantomData<*const ()>,
}
unsafe impl Send for Dma {}
impl Dma {
    #[doc = r"Pointer to the register block"]
    pub const PTR: *const dma::RegisterBlock = 0x4002_6000 as *const _;
    #[doc = r"Return the pointer to the register block"]
    #[inline(always)]
    pub const fn ptr() -> *const dma::RegisterBlock {
        Self::PTR
    }
    #[doc = r" Steal an instance of this peripheral"]
    #[doc = r""]
    #[doc = r" # Safety"]
    #[doc = r""]
    #[doc = r" Ensure that the new instance of the peripheral cannot be used in a way"]
    #[doc = r" that may race with any existing instances, for example by only"]
    #[doc = r" accessing read-only or write-only registers, or by consuming the"]
    #[doc = r" original peripheral and using critical sections to coordinate"]
    #[doc = r" access between multiple new instances."]
    #[doc = r""]
    #[doc = r" Additionally, other software such as HALs may rely on only one"]
    #[doc = r" peripheral instance existing to ensure memory safety; ensure"]
    #[doc = r" no stolen instances are passed to such software."]
    pub unsafe fn steal() -> Self {
        Self {
            _marker: PhantomData,
        }
    }
}
impl Deref for Dma {
    type Target = dma::RegisterBlock;
    #[inline(always)]
    fn deref(&self) -> &Self::Target {
        unsafe { &*Self::PTR }
    }
}
impl core::fmt::Debug for Dma {
    fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
        f.debug_struct("Dma").finish()
    }
}
#[doc = "ARM Micro Direct Memory Access Controller"]
pub mod dma;
#[doc = "Serial Peripheral Interface (SPI) module with peripheral and controller capabilities."]
pub struct Spi0 {
    _marker: PhantomData<*const ()>,
}
unsafe impl Send for Spi0 {}
impl Spi0 {
    #[doc = r"Pointer to the register block"]
    pub const PTR: *const spi0::RegisterBlock = 0x4003_0000 as *const _;
    #[doc = r"Return the pointer to the register block"]
    #[inline(always)]
    pub const fn ptr() -> *const spi0::RegisterBlock {
        Self::PTR
    }
    #[doc = r" Steal an instance of this peripheral"]
    #[doc = r""]
    #[doc = r" # Safety"]
    #[doc = r""]
    #[doc = r" Ensure that the new instance of the peripheral cannot be used in a way"]
    #[doc = r" that may race with any existing instances, for example by only"]
    #[doc = r" accessing read-only or write-only registers, or by consuming the"]
    #[doc = r" original peripheral and using critical sections to coordinate"]
    #[doc = r" access between multiple new instances."]
    #[doc = r""]
    #[doc = r" Additionally, other software such as HALs may rely on only one"]
    #[doc = r" peripheral instance existing to ensure memory safety; ensure"]
    #[doc = r" no stolen instances are passed to such software."]
    pub unsafe fn steal() -> Self {
        Self {
            _marker: PhantomData,
        }
    }
}
impl Deref for Spi0 {
    type Target = spi0::RegisterBlock;
    #[inline(always)]
    fn deref(&self) -> &Self::Target {
        unsafe { &*Self::PTR }
    }
}
impl core::fmt::Debug for Spi0 {
    fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
        f.debug_struct("Spi0").finish()
    }
}
#[doc = "Serial Peripheral Interface (SPI) module with peripheral and controller capabilities."]
pub mod spi0;
#[doc = "Universal Asynchronous Receiver/Transmitter (UART) interface"]
pub struct Uart0 {
    _marker: PhantomData<*const ()>,
}
unsafe impl Send for Uart0 {}
impl Uart0 {
    #[doc = r"Pointer to the register block"]
    pub const PTR: *const uart0::RegisterBlock = 0x4003_4000 as *const _;
    #[doc = r"Return the pointer to the register block"]
    #[inline(always)]
    pub const fn ptr() -> *const uart0::RegisterBlock {
        Self::PTR
    }
    #[doc = r" Steal an instance of this peripheral"]
    #[doc = r""]
    #[doc = r" # Safety"]
    #[doc = r""]
    #[doc = r" Ensure that the new instance of the peripheral cannot be used in a way"]
    #[doc = r" that may race with any existing instances, for example by only"]
    #[doc = r" accessing read-only or write-only registers, or by consuming the"]
    #[doc = r" original peripheral and using critical sections to coordinate"]
    #[doc = r" access between multiple new instances."]
    #[doc = r""]
    #[doc = r" Additionally, other software such as HALs may rely on only one"]
    #[doc = r" peripheral instance existing to ensure memory safety; ensure"]
    #[doc = r" no stolen instances are passed to such software."]
    pub unsafe fn steal() -> Self {
        Self {
            _marker: PhantomData,
        }
    }
}
impl Deref for Uart0 {
    type Target = uart0::RegisterBlock;
    #[inline(always)]
    fn deref(&self) -> &Self::Target {
        unsafe { &*Self::PTR }
    }
}
impl core::fmt::Debug for Uart0 {
    fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
        f.debug_struct("Uart0").finish()
    }
}
#[doc = "Universal Asynchronous Receiver/Transmitter (UART) interface"]
pub mod uart0;
#[doc = "I2C IP"]
pub struct I2c0 {
    _marker: PhantomData<*const ()>,
}
unsafe impl Send for I2c0 {}
impl I2c0 {
    #[doc = r"Pointer to the register block"]
    pub const PTR: *const i2c0::RegisterBlock = 0x4003_8000 as *const _;
    #[doc = r"Return the pointer to the register block"]
    #[inline(always)]
    pub const fn ptr() -> *const i2c0::RegisterBlock {
        Self::PTR
    }
    #[doc = r" Steal an instance of this peripheral"]
    #[doc = r""]
    #[doc = r" # Safety"]
    #[doc = r""]
    #[doc = r" Ensure that the new instance of the peripheral cannot be used in a way"]
    #[doc = r" that may race with any existing instances, for example by only"]
    #[doc = r" accessing read-only or write-only registers, or by consuming the"]
    #[doc = r" original peripheral and using critical sections to coordinate"]
    #[doc = r" access between multiple new instances."]
    #[doc = r""]
    #[doc = r" Additionally, other software such as HALs may rely on only one"]
    #[doc = r" peripheral instance existing to ensure memory safety; ensure"]
    #[doc = r" no stolen instances are passed to such software."]
    pub unsafe fn steal() -> Self {
        Self {
            _marker: PhantomData,
        }
    }
}
impl Deref for I2c0 {
    type Target = i2c0::RegisterBlock;
    #[inline(always)]
    fn deref(&self) -> &Self::Target {
        unsafe { &*Self::PTR }
    }
}
impl core::fmt::Debug for I2c0 {
    fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
        f.debug_struct("I2c0").finish()
    }
}
#[doc = "I2C IP"]
pub mod i2c0;
#[doc = "ADC (Analog to Digital Converter) module"]
pub struct Adc {
    _marker: PhantomData<*const ()>,
}
unsafe impl Send for Adc {}
impl Adc {
    #[doc = r"Pointer to the register block"]
    pub const PTR: *const adc::RegisterBlock = 0x4005_0000 as *const _;
    #[doc = r"Return the pointer to the register block"]
    #[inline(always)]
    pub const fn ptr() -> *const adc::RegisterBlock {
        Self::PTR
    }
    #[doc = r" Steal an instance of this peripheral"]
    #[doc = r""]
    #[doc = r" # Safety"]
    #[doc = r""]
    #[doc = r" Ensure that the new instance of the peripheral cannot be used in a way"]
    #[doc = r" that may race with any existing instances, for example by only"]
    #[doc = r" accessing read-only or write-only registers, or by consuming the"]
    #[doc = r" original peripheral and using critical sections to coordinate"]
    #[doc = r" access between multiple new instances."]
    #[doc = r""]
    #[doc = r" Additionally, other software such as HALs may rely on only one"]
    #[doc = r" peripheral instance existing to ensure memory safety; ensure"]
    #[doc = r" no stolen instances are passed to such software."]
    pub unsafe fn steal() -> Self {
        Self {
            _marker: PhantomData,
        }
    }
}
impl Deref for Adc {
    type Target = adc::RegisterBlock;
    #[inline(always)]
    fn deref(&self) -> &Self::Target {
        unsafe { &*Self::PTR }
    }
}
impl core::fmt::Debug for Adc {
    fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
        f.debug_struct("Adc").finish()
    }
}
#[doc = "ADC (Analog to Digital Converter) module"]
pub mod adc;
#[doc = "This component is a general purpose timer. The timer offers - generation of waveforms and events. - capture of signal period and duty cycle. - generation of IR signals. - decoding of quadrature encoded signals. - motor control features. It consists of a - 16-bit counter. - 8-bit prescaler - 3 capture compare channels. - 3 event outputs. - 3 capture inputs. Each channel subscribes to the synchronous event bus. They can control one or more event outputs in both capture and compare modes. PRECFG.TICKSRC selects tick source for the timer."]
pub struct Lgpt0 {
    _marker: PhantomData<*const ()>,
}
unsafe impl Send for Lgpt0 {}
impl Lgpt0 {
    #[doc = r"Pointer to the register block"]
    pub const PTR: *const lgpt0::RegisterBlock = 0x4006_0000 as *const _;
    #[doc = r"Return the pointer to the register block"]
    #[inline(always)]
    pub const fn ptr() -> *const lgpt0::RegisterBlock {
        Self::PTR
    }
    #[doc = r" Steal an instance of this peripheral"]
    #[doc = r""]
    #[doc = r" # Safety"]
    #[doc = r""]
    #[doc = r" Ensure that the new instance of the peripheral cannot be used in a way"]
    #[doc = r" that may race with any existing instances, for example by only"]
    #[doc = r" accessing read-only or write-only registers, or by consuming the"]
    #[doc = r" original peripheral and using critical sections to coordinate"]
    #[doc = r" access between multiple new instances."]
    #[doc = r""]
    #[doc = r" Additionally, other software such as HALs may rely on only one"]
    #[doc = r" peripheral instance existing to ensure memory safety; ensure"]
    #[doc = r" no stolen instances are passed to such software."]
    pub unsafe fn steal() -> Self {
        Self {
            _marker: PhantomData,
        }
    }
}
impl Deref for Lgpt0 {
    type Target = lgpt0::RegisterBlock;
    #[inline(always)]
    fn deref(&self) -> &Self::Target {
        unsafe { &*Self::PTR }
    }
}
impl core::fmt::Debug for Lgpt0 {
    fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
        f.debug_struct("Lgpt0").finish()
    }
}
#[doc = "This component is a general purpose timer. The timer offers - generation of waveforms and events. - capture of signal period and duty cycle. - generation of IR signals. - decoding of quadrature encoded signals. - motor control features. It consists of a - 16-bit counter. - 8-bit prescaler - 3 capture compare channels. - 3 event outputs. - 3 capture inputs. Each channel subscribes to the synchronous event bus. They can control one or more event outputs in both capture and compare modes. PRECFG.TICKSRC selects tick source for the timer."]
pub mod lgpt0;
#[doc = "This component is a general purpose timer. The timer offers - generation of waveforms and events. - capture of signal period and duty cycle. - generation of IR signals. - decoding of quadrature encoded signals. - motor control features. It consists of a - 16-bit counter. - 8-bit prescaler - 3 capture compare channels. - 3 event outputs. - 3 capture inputs. Each channel subscribes to the synchronous event bus. They can control one or more event outputs in both capture and compare modes. PRECFG.TICKSRC selects tick source for the timer."]
pub struct Lgpt1 {
    _marker: PhantomData<*const ()>,
}
unsafe impl Send for Lgpt1 {}
impl Lgpt1 {
    #[doc = r"Pointer to the register block"]
    pub const PTR: *const lgpt1::RegisterBlock = 0x4006_1000 as *const _;
    #[doc = r"Return the pointer to the register block"]
    #[inline(always)]
    pub const fn ptr() -> *const lgpt1::RegisterBlock {
        Self::PTR
    }
    #[doc = r" Steal an instance of this peripheral"]
    #[doc = r""]
    #[doc = r" # Safety"]
    #[doc = r""]
    #[doc = r" Ensure that the new instance of the peripheral cannot be used in a way"]
    #[doc = r" that may race with any existing instances, for example by only"]
    #[doc = r" accessing read-only or write-only registers, or by consuming the"]
    #[doc = r" original peripheral and using critical sections to coordinate"]
    #[doc = r" access between multiple new instances."]
    #[doc = r""]
    #[doc = r" Additionally, other software such as HALs may rely on only one"]
    #[doc = r" peripheral instance existing to ensure memory safety; ensure"]
    #[doc = r" no stolen instances are passed to such software."]
    pub unsafe fn steal() -> Self {
        Self {
            _marker: PhantomData,
        }
    }
}
impl Deref for Lgpt1 {
    type Target = lgpt1::RegisterBlock;
    #[inline(always)]
    fn deref(&self) -> &Self::Target {
        unsafe { &*Self::PTR }
    }
}
impl core::fmt::Debug for Lgpt1 {
    fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
        f.debug_struct("Lgpt1").finish()
    }
}
#[doc = "This component is a general purpose timer. The timer offers - generation of waveforms and events. - capture of signal period and duty cycle. - generation of IR signals. - decoding of quadrature encoded signals. - motor control features. It consists of a - 16-bit counter. - 8-bit prescaler - 3 capture compare channels. - 3 event outputs. - 3 capture inputs. Each channel subscribes to the synchronous event bus. They can control one or more event outputs in both capture and compare modes. PRECFG.TICKSRC selects tick source for the timer."]
pub mod lgpt1;
#[doc = "This component is a general purpose timer. The timer offers - generation of waveforms and events. - capture of signal period and duty cycle. - generation of IR signals. - decoding of quadrature encoded signals. - motor control features. It consists of a - 16-bit counter. - 8-bit prescaler - 3 capture compare channels. - 3 event outputs. - 3 capture inputs. Each channel subscribes to the synchronous event bus. They can control one or more event outputs in both capture and compare modes. PRECFG.TICKSRC selects tick source for the timer."]
pub struct Lgpt2 {
    _marker: PhantomData<*const ()>,
}
unsafe impl Send for Lgpt2 {}
impl Lgpt2 {
    #[doc = r"Pointer to the register block"]
    pub const PTR: *const lgpt2::RegisterBlock = 0x4006_2000 as *const _;
    #[doc = r"Return the pointer to the register block"]
    #[inline(always)]
    pub const fn ptr() -> *const lgpt2::RegisterBlock {
        Self::PTR
    }
    #[doc = r" Steal an instance of this peripheral"]
    #[doc = r""]
    #[doc = r" # Safety"]
    #[doc = r""]
    #[doc = r" Ensure that the new instance of the peripheral cannot be used in a way"]
    #[doc = r" that may race with any existing instances, for example by only"]
    #[doc = r" accessing read-only or write-only registers, or by consuming the"]
    #[doc = r" original peripheral and using critical sections to coordinate"]
    #[doc = r" access between multiple new instances."]
    #[doc = r""]
    #[doc = r" Additionally, other software such as HALs may rely on only one"]
    #[doc = r" peripheral instance existing to ensure memory safety; ensure"]
    #[doc = r" no stolen instances are passed to such software."]
    pub unsafe fn steal() -> Self {
        Self {
            _marker: PhantomData,
        }
    }
}
impl Deref for Lgpt2 {
    type Target = lgpt2::RegisterBlock;
    #[inline(always)]
    fn deref(&self) -> &Self::Target {
        unsafe { &*Self::PTR }
    }
}
impl core::fmt::Debug for Lgpt2 {
    fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
        f.debug_struct("Lgpt2").finish()
    }
}
#[doc = "This component is a general purpose timer. The timer offers - generation of waveforms and events. - capture of signal period and duty cycle. - generation of IR signals. - decoding of quadrature encoded signals. - motor control features. It consists of a - 16-bit counter. - 8-bit prescaler - 3 capture compare channels. - 3 event outputs. - 3 capture inputs. Each channel subscribes to the synchronous event bus. They can control one or more event outputs in both capture and compare modes. PRECFG.TICKSRC selects tick source for the timer."]
pub mod lgpt2;
#[doc = "This component is a general purpose timer. The timer offers - generation of waveforms and events. - capture of signal period and duty cycle. - generation of IR signals. - decoding of quadrature encoded signals. - motor control features. It consists of a - 16-bit counter. - 8-bit prescaler - 3 capture compare channels. - 3 event outputs. - 3 capture inputs. Each channel subscribes to the synchronous event bus. They can control one or more event outputs in both capture and compare modes. PRECFG.TICKSRC selects tick source for the timer."]
pub struct Lgpt3 {
    _marker: PhantomData<*const ()>,
}
unsafe impl Send for Lgpt3 {}
impl Lgpt3 {
    #[doc = r"Pointer to the register block"]
    pub const PTR: *const lgpt3::RegisterBlock = 0x4006_3000 as *const _;
    #[doc = r"Return the pointer to the register block"]
    #[inline(always)]
    pub const fn ptr() -> *const lgpt3::RegisterBlock {
        Self::PTR
    }
    #[doc = r" Steal an instance of this peripheral"]
    #[doc = r""]
    #[doc = r" # Safety"]
    #[doc = r""]
    #[doc = r" Ensure that the new instance of the peripheral cannot be used in a way"]
    #[doc = r" that may race with any existing instances, for example by only"]
    #[doc = r" accessing read-only or write-only registers, or by consuming the"]
    #[doc = r" original peripheral and using critical sections to coordinate"]
    #[doc = r" access between multiple new instances."]
    #[doc = r""]
    #[doc = r" Additionally, other software such as HALs may rely on only one"]
    #[doc = r" peripheral instance existing to ensure memory safety; ensure"]
    #[doc = r" no stolen instances are passed to such software."]
    pub unsafe fn steal() -> Self {
        Self {
            _marker: PhantomData,
        }
    }
}
impl Deref for Lgpt3 {
    type Target = lgpt3::RegisterBlock;
    #[inline(always)]
    fn deref(&self) -> &Self::Target {
        unsafe { &*Self::PTR }
    }
}
impl core::fmt::Debug for Lgpt3 {
    fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
        f.debug_struct("Lgpt3").finish()
    }
}
#[doc = "This component is a general purpose timer. The timer offers - generation of waveforms and events. - capture of signal period and duty cycle. - generation of IR signals. - decoding of quadrature encoded signals. - motor control features. It consists of a - 16-bit counter. - 8-bit prescaler - 3 capture compare channels. - 3 event outputs. - 3 capture inputs. Each channel subscribes to the synchronous event bus. They can control one or more event outputs in both capture and compare modes. PRECFG.TICKSRC selects tick source for the timer."]
pub mod lgpt3;
#[doc = "LRFDDBELL"]
pub struct Lrfddbell {
    _marker: PhantomData<*const ()>,
}
unsafe impl Send for Lrfddbell {}
impl Lrfddbell {
    #[doc = r"Pointer to the register block"]
    pub const PTR: *const lrfddbell::RegisterBlock = 0x4008_0000 as *const _;
    #[doc = r"Return the pointer to the register block"]
    #[inline(always)]
    pub const fn ptr() -> *const lrfddbell::RegisterBlock {
        Self::PTR
    }
    #[doc = r" Steal an instance of this peripheral"]
    #[doc = r""]
    #[doc = r" # Safety"]
    #[doc = r""]
    #[doc = r" Ensure that the new instance of the peripheral cannot be used in a way"]
    #[doc = r" that may race with any existing instances, for example by only"]
    #[doc = r" accessing read-only or write-only registers, or by consuming the"]
    #[doc = r" original peripheral and using critical sections to coordinate"]
    #[doc = r" access between multiple new instances."]
    #[doc = r""]
    #[doc = r" Additionally, other software such as HALs may rely on only one"]
    #[doc = r" peripheral instance existing to ensure memory safety; ensure"]
    #[doc = r" no stolen instances are passed to such software."]
    pub unsafe fn steal() -> Self {
        Self {
            _marker: PhantomData,
        }
    }
}
impl Deref for Lrfddbell {
    type Target = lrfddbell::RegisterBlock;
    #[inline(always)]
    fn deref(&self) -> &Self::Target {
        unsafe { &*Self::PTR }
    }
}
impl core::fmt::Debug for Lrfddbell {
    fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
        f.debug_struct("Lrfddbell").finish()
    }
}
#[doc = "LRFDDBELL"]
pub mod lrfddbell;
#[doc = "LRFDTXF"]
pub struct Lrfdtxf {
    _marker: PhantomData<*const ()>,
}
unsafe impl Send for Lrfdtxf {}
impl Lrfdtxf {
    #[doc = r"Pointer to the register block"]
    pub const PTR: *const lrfdtxf::RegisterBlock = 0x4008_1800 as *const _;
    #[doc = r"Return the pointer to the register block"]
    #[inline(always)]
    pub const fn ptr() -> *const lrfdtxf::RegisterBlock {
        Self::PTR
    }
    #[doc = r" Steal an instance of this peripheral"]
    #[doc = r""]
    #[doc = r" # Safety"]
    #[doc = r""]
    #[doc = r" Ensure that the new instance of the peripheral cannot be used in a way"]
    #[doc = r" that may race with any existing instances, for example by only"]
    #[doc = r" accessing read-only or write-only registers, or by consuming the"]
    #[doc = r" original peripheral and using critical sections to coordinate"]
    #[doc = r" access between multiple new instances."]
    #[doc = r""]
    #[doc = r" Additionally, other software such as HALs may rely on only one"]
    #[doc = r" peripheral instance existing to ensure memory safety; ensure"]
    #[doc = r" no stolen instances are passed to such software."]
    pub unsafe fn steal() -> Self {
        Self {
            _marker: PhantomData,
        }
    }
}
impl Deref for Lrfdtxf {
    type Target = lrfdtxf::RegisterBlock;
    #[inline(always)]
    fn deref(&self) -> &Self::Target {
        unsafe { &*Self::PTR }
    }
}
impl core::fmt::Debug for Lrfdtxf {
    fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
        f.debug_struct("Lrfdtxf").finish()
    }
}
#[doc = "LRFDTXF"]
pub mod lrfdtxf;
#[doc = "LRFDRXF"]
pub struct Lrfdrxf {
    _marker: PhantomData<*const ()>,
}
unsafe impl Send for Lrfdrxf {}
impl Lrfdrxf {
    #[doc = r"Pointer to the register block"]
    pub const PTR: *const lrfdrxf::RegisterBlock = 0x4008_1c00 as *const _;
    #[doc = r"Return the pointer to the register block"]
    #[inline(always)]
    pub const fn ptr() -> *const lrfdrxf::RegisterBlock {
        Self::PTR
    }
    #[doc = r" Steal an instance of this peripheral"]
    #[doc = r""]
    #[doc = r" # Safety"]
    #[doc = r""]
    #[doc = r" Ensure that the new instance of the peripheral cannot be used in a way"]
    #[doc = r" that may race with any existing instances, for example by only"]
    #[doc = r" accessing read-only or write-only registers, or by consuming the"]
    #[doc = r" original peripheral and using critical sections to coordinate"]
    #[doc = r" access between multiple new instances."]
    #[doc = r""]
    #[doc = r" Additionally, other software such as HALs may rely on only one"]
    #[doc = r" peripheral instance existing to ensure memory safety; ensure"]
    #[doc = r" no stolen instances are passed to such software."]
    pub unsafe fn steal() -> Self {
        Self {
            _marker: PhantomData,
        }
    }
}
impl Deref for Lrfdrxf {
    type Target = lrfdrxf::RegisterBlock;
    #[inline(always)]
    fn deref(&self) -> &Self::Target {
        unsafe { &*Self::PTR }
    }
}
impl core::fmt::Debug for Lrfdrxf {
    fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
        f.debug_struct("Lrfdrxf").finish()
    }
}
#[doc = "LRFDRXF"]
pub mod lrfdrxf;
#[doc = "The AES-128 crypto peripheral accellerates AES-128 block cipher encryption (ECB). The peripheral does also offer hardware features to accellerate cipher modes implemented in software: * CBC-MAC * CBC * CTR * CFB * OFB * PCBC The module provides two data registers that can be input to ECB encryption. These are termed TXT and BUF. TXT is the AES-128 work buffer, and content changes during an ECB encryption. Software cannot update TXT during encryption. BUF is an auxiliary 128-bit buffer with multiple purposes: * initialization vector(IV) storage * counter in CTR cipher mode * hold next value of TXT Software can update BUF during an ECB enryption. This allows software to write next TXT during an encryption an hence save ECB idle times."]
pub struct Aes {
    _marker: PhantomData<*const ()>,
}
unsafe impl Send for Aes {}
impl Aes {
    #[doc = r"Pointer to the register block"]
    pub const PTR: *const aes::RegisterBlock = 0x400c_0000 as *const _;
    #[doc = r"Return the pointer to the register block"]
    #[inline(always)]
    pub const fn ptr() -> *const aes::RegisterBlock {
        Self::PTR
    }
    #[doc = r" Steal an instance of this peripheral"]
    #[doc = r""]
    #[doc = r" # Safety"]
    #[doc = r""]
    #[doc = r" Ensure that the new instance of the peripheral cannot be used in a way"]
    #[doc = r" that may race with any existing instances, for example by only"]
    #[doc = r" accessing read-only or write-only registers, or by consuming the"]
    #[doc = r" original peripheral and using critical sections to coordinate"]
    #[doc = r" access between multiple new instances."]
    #[doc = r""]
    #[doc = r" Additionally, other software such as HALs may rely on only one"]
    #[doc = r" peripheral instance existing to ensure memory safety; ensure"]
    #[doc = r" no stolen instances are passed to such software."]
    pub unsafe fn steal() -> Self {
        Self {
            _marker: PhantomData,
        }
    }
}
impl Deref for Aes {
    type Target = aes::RegisterBlock;
    #[inline(always)]
    fn deref(&self) -> &Self::Target {
        unsafe { &*Self::PTR }
    }
}
impl core::fmt::Debug for Aes {
    fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
        f.debug_struct("Aes").finish()
    }
}
#[doc = "The AES-128 crypto peripheral accellerates AES-128 block cipher encryption (ECB). The peripheral does also offer hardware features to accellerate cipher modes implemented in software: * CBC-MAC * CBC * CTR * CFB * OFB * PCBC The module provides two data registers that can be input to ECB encryption. These are termed TXT and BUF. TXT is the AES-128 work buffer, and content changes during an ECB encryption. Software cannot update TXT during encryption. BUF is an auxiliary 128-bit buffer with multiple purposes: * initialization vector(IV) storage * counter in CTR cipher mode * hold next value of TXT Software can update BUF during an ECB enryption. This allows software to write next TXT during an encryption an hence save ECB idle times."]
pub mod aes;
#[doc = "BPU"]
pub struct Bpu {
    _marker: PhantomData<*const ()>,
}
unsafe impl Send for Bpu {}
impl Bpu {
    #[doc = r"Pointer to the register block"]
    pub const PTR: *const bpu::RegisterBlock = 0xe000_2000 as *const _;
    #[doc = r"Return the pointer to the register block"]
    #[inline(always)]
    pub const fn ptr() -> *const bpu::RegisterBlock {
        Self::PTR
    }
    #[doc = r" Steal an instance of this peripheral"]
    #[doc = r""]
    #[doc = r" # Safety"]
    #[doc = r""]
    #[doc = r" Ensure that the new instance of the peripheral cannot be used in a way"]
    #[doc = r" that may race with any existing instances, for example by only"]
    #[doc = r" accessing read-only or write-only registers, or by consuming the"]
    #[doc = r" original peripheral and using critical sections to coordinate"]
    #[doc = r" access between multiple new instances."]
    #[doc = r""]
    #[doc = r" Additionally, other software such as HALs may rely on only one"]
    #[doc = r" peripheral instance existing to ensure memory safety; ensure"]
    #[doc = r" no stolen instances are passed to such software."]
    pub unsafe fn steal() -> Self {
        Self {
            _marker: PhantomData,
        }
    }
}
impl Deref for Bpu {
    type Target = bpu::RegisterBlock;
    #[inline(always)]
    fn deref(&self) -> &Self::Target {
        unsafe { &*Self::PTR }
    }
}
impl core::fmt::Debug for Bpu {
    fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
        f.debug_struct("Bpu").finish()
    }
}
#[doc = "BPU"]
pub mod bpu;
#[doc = "SYSTICK"]
pub struct Systick {
    _marker: PhantomData<*const ()>,
}
unsafe impl Send for Systick {}
impl Systick {
    #[doc = r"Pointer to the register block"]
    pub const PTR: *const systick::RegisterBlock = 0xe000_e010 as *const _;
    #[doc = r"Return the pointer to the register block"]
    #[inline(always)]
    pub const fn ptr() -> *const systick::RegisterBlock {
        Self::PTR
    }
    #[doc = r" Steal an instance of this peripheral"]
    #[doc = r""]
    #[doc = r" # Safety"]
    #[doc = r""]
    #[doc = r" Ensure that the new instance of the peripheral cannot be used in a way"]
    #[doc = r" that may race with any existing instances, for example by only"]
    #[doc = r" accessing read-only or write-only registers, or by consuming the"]
    #[doc = r" original peripheral and using critical sections to coordinate"]
    #[doc = r" access between multiple new instances."]
    #[doc = r""]
    #[doc = r" Additionally, other software such as HALs may rely on only one"]
    #[doc = r" peripheral instance existing to ensure memory safety; ensure"]
    #[doc = r" no stolen instances are passed to such software."]
    pub unsafe fn steal() -> Self {
        Self {
            _marker: PhantomData,
        }
    }
}
impl Deref for Systick {
    type Target = systick::RegisterBlock;
    #[inline(always)]
    fn deref(&self) -> &Self::Target {
        unsafe { &*Self::PTR }
    }
}
impl core::fmt::Debug for Systick {
    fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
        f.debug_struct("Systick").finish()
    }
}
#[doc = "SYSTICK"]
pub mod systick;
#[doc = "SCSCS"]
pub struct Scscs {
    _marker: PhantomData<*const ()>,
}
unsafe impl Send for Scscs {}
impl Scscs {
    #[doc = r"Pointer to the register block"]
    pub const PTR: *const scscs::RegisterBlock = 0xe000_efc0 as *const _;
    #[doc = r"Return the pointer to the register block"]
    #[inline(always)]
    pub const fn ptr() -> *const scscs::RegisterBlock {
        Self::PTR
    }
    #[doc = r" Steal an instance of this peripheral"]
    #[doc = r""]
    #[doc = r" # Safety"]
    #[doc = r""]
    #[doc = r" Ensure that the new instance of the peripheral cannot be used in a way"]
    #[doc = r" that may race with any existing instances, for example by only"]
    #[doc = r" accessing read-only or write-only registers, or by consuming the"]
    #[doc = r" original peripheral and using critical sections to coordinate"]
    #[doc = r" access between multiple new instances."]
    #[doc = r""]
    #[doc = r" Additionally, other software such as HALs may rely on only one"]
    #[doc = r" peripheral instance existing to ensure memory safety; ensure"]
    #[doc = r" no stolen instances are passed to such software."]
    pub unsafe fn steal() -> Self {
        Self {
            _marker: PhantomData,
        }
    }
}
impl Deref for Scscs {
    type Target = scscs::RegisterBlock;
    #[inline(always)]
    fn deref(&self) -> &Self::Target {
        unsafe { &*Self::PTR }
    }
}
impl core::fmt::Debug for Scscs {
    fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
        f.debug_struct("Scscs").finish()
    }
}
#[doc = "SCSCS"]
pub mod scscs;
#[doc = "CPU_ROM_TABLE"]
pub struct CpuRomTable {
    _marker: PhantomData<*const ()>,
}
unsafe impl Send for CpuRomTable {}
impl CpuRomTable {
    #[doc = r"Pointer to the register block"]
    pub const PTR: *const cpu_rom_table::RegisterBlock = 0xe00f_f000 as *const _;
    #[doc = r"Return the pointer to the register block"]
    #[inline(always)]
    pub const fn ptr() -> *const cpu_rom_table::RegisterBlock {
        Self::PTR
    }
    #[doc = r" Steal an instance of this peripheral"]
    #[doc = r""]
    #[doc = r" # Safety"]
    #[doc = r""]
    #[doc = r" Ensure that the new instance of the peripheral cannot be used in a way"]
    #[doc = r" that may race with any existing instances, for example by only"]
    #[doc = r" accessing read-only or write-only registers, or by consuming the"]
    #[doc = r" original peripheral and using critical sections to coordinate"]
    #[doc = r" access between multiple new instances."]
    #[doc = r""]
    #[doc = r" Additionally, other software such as HALs may rely on only one"]
    #[doc = r" peripheral instance existing to ensure memory safety; ensure"]
    #[doc = r" no stolen instances are passed to such software."]
    pub unsafe fn steal() -> Self {
        Self {
            _marker: PhantomData,
        }
    }
}
impl Deref for CpuRomTable {
    type Target = cpu_rom_table::RegisterBlock;
    #[inline(always)]
    fn deref(&self) -> &Self::Target {
        unsafe { &*Self::PTR }
    }
}
impl core::fmt::Debug for CpuRomTable {
    fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
        f.debug_struct("CpuRomTable").finish()
    }
}
#[doc = "CPU_ROM_TABLE"]
pub mod cpu_rom_table;
#[no_mangle]
static mut DEVICE_PERIPHERALS: bool = false;
#[doc = r" All the peripherals."]
#[allow(non_snake_case)]
pub struct Peripherals {
    #[doc = "PMCTL"]
    pub pmctl: Pmctl,
    #[doc = "CKMD"]
    pub ckmd: Ckmd,
    #[doc = "RTC"]
    pub rtc: Rtc,
    #[doc = "IOC"]
    pub ioc: Ioc,
    #[doc = "SYS0"]
    pub sys0: Sys0,
    #[doc = "EVTULL"]
    pub evtull: Evtull,
    #[doc = "PMUD"]
    pub pmud: Pmud,
    #[doc = "DBGSS"]
    pub dbgss: Dbgss,
    #[doc = "CLKCTL"]
    pub clkctl: Clkctl,
    #[doc = "FLASH"]
    pub flash: Flash,
    #[doc = "SYSTIM"]
    pub systim: Systim,
    #[doc = "GPIO"]
    pub gpio: Gpio,
    #[doc = "VIMS"]
    pub vims: Vims,
    #[doc = "EVTSVT"]
    pub evtsvt: Evtsvt,
    #[doc = "DMA"]
    pub dma: Dma,
    #[doc = "SPI0"]
    pub spi0: Spi0,
    #[doc = "UART0"]
    pub uart0: Uart0,
    #[doc = "I2C0"]
    pub i2c0: I2c0,
    #[doc = "ADC"]
    pub adc: Adc,
    #[doc = "LGPT0"]
    pub lgpt0: Lgpt0,
    #[doc = "LGPT1"]
    pub lgpt1: Lgpt1,
    #[doc = "LGPT2"]
    pub lgpt2: Lgpt2,
    #[doc = "LGPT3"]
    pub lgpt3: Lgpt3,
    #[doc = "LRFDDBELL"]
    pub lrfddbell: Lrfddbell,
    #[doc = "LRFDTXF"]
    pub lrfdtxf: Lrfdtxf,
    #[doc = "LRFDRXF"]
    pub lrfdrxf: Lrfdrxf,
    #[doc = "AES"]
    pub aes: Aes,
    #[doc = "BPU"]
    pub bpu: Bpu,
    #[doc = "SYSTICK"]
    pub systick: Systick,
    #[doc = "SCSCS"]
    pub scscs: Scscs,
    #[doc = "CPU_ROM_TABLE"]
    pub cpu_rom_table: CpuRomTable,
}
impl Peripherals {
    #[doc = r" Returns all the peripherals *once*."]
    #[cfg(feature = "critical-section")]
    #[inline]
    pub fn take() -> Option<Self> {
        critical_section::with(|_| {
            if unsafe { DEVICE_PERIPHERALS } {
                return None;
            }
            Some(unsafe { Peripherals::steal() })
        })
    }
    #[doc = r" Unchecked version of `Peripherals::take`."]
    #[doc = r""]
    #[doc = r" # Safety"]
    #[doc = r""]
    #[doc = r" Each of the returned peripherals must be used at most once."]
    #[inline]
    pub unsafe fn steal() -> Self {
        DEVICE_PERIPHERALS = true;
        Peripherals {
            pmctl: Pmctl {
                _marker: PhantomData,
            },
            ckmd: Ckmd {
                _marker: PhantomData,
            },
            rtc: Rtc {
                _marker: PhantomData,
            },
            ioc: Ioc {
                _marker: PhantomData,
            },
            sys0: Sys0 {
                _marker: PhantomData,
            },
            evtull: Evtull {
                _marker: PhantomData,
            },
            pmud: Pmud {
                _marker: PhantomData,
            },
            dbgss: Dbgss {
                _marker: PhantomData,
            },
            clkctl: Clkctl {
                _marker: PhantomData,
            },
            flash: Flash {
                _marker: PhantomData,
            },
            systim: Systim {
                _marker: PhantomData,
            },
            gpio: Gpio {
                _marker: PhantomData,
            },
            vims: Vims {
                _marker: PhantomData,
            },
            evtsvt: Evtsvt {
                _marker: PhantomData,
            },
            dma: Dma {
                _marker: PhantomData,
            },
            spi0: Spi0 {
                _marker: PhantomData,
            },
            uart0: Uart0 {
                _marker: PhantomData,
            },
            i2c0: I2c0 {
                _marker: PhantomData,
            },
            adc: Adc {
                _marker: PhantomData,
            },
            lgpt0: Lgpt0 {
                _marker: PhantomData,
            },
            lgpt1: Lgpt1 {
                _marker: PhantomData,
            },
            lgpt2: Lgpt2 {
                _marker: PhantomData,
            },
            lgpt3: Lgpt3 {
                _marker: PhantomData,
            },
            lrfddbell: Lrfddbell {
                _marker: PhantomData,
            },
            lrfdtxf: Lrfdtxf {
                _marker: PhantomData,
            },
            lrfdrxf: Lrfdrxf {
                _marker: PhantomData,
            },
            aes: Aes {
                _marker: PhantomData,
            },
            bpu: Bpu {
                _marker: PhantomData,
            },
            systick: Systick {
                _marker: PhantomData,
            },
            scscs: Scscs {
                _marker: PhantomData,
            },
            cpu_rom_table: CpuRomTable {
                _marker: PhantomData,
            },
        }
    }
}
#[doc = "Customer Configuration Area (CCFG)"]
pub mod ccfg;
