#![doc = "Peripheral access API for CC2652 microcontrollers (generated using svd2rust v0.28.0 ( ))\n\nYou can find an overview of the generated API [here].\n\nAPI features to be included in the [next]
svd2rust release can be generated by cloning the svd2rust [repository], checking out the above commit, and running `cargo doc --open`.\n\n[here]: https://docs.rs/svd2rust/0.28.0/svd2rust/#peripheral-api\n[next]: https://github.com/rust-embedded/svd2rust/blob/master/CHANGELOG.md#unreleased\n[repository]: https://github.com/rust-embedded/svd2rust"]
#![deny(dead_code)]
#![deny(improper_ctypes)]
#![deny(missing_docs)]
#![deny(no_mangle_generic_items)]
#![deny(non_shorthand_field_patterns)]
#![deny(overflowing_literals)]
#![deny(path_statements)]
#![deny(patterns_in_fns_without_body)]
#![deny(private_in_public)]
#![deny(unconditional_recursion)]
#![deny(unused_allocation)]
#![deny(unused_comparisons)]
#![deny(unused_parens)]
#![deny(while_true)]
#![allow(non_camel_case_types)]
#![allow(non_snake_case)]
#![no_std]
use core::marker::PhantomData;
use core::ops::Deref;
#[doc = r"Number available in the NVIC for configuring priority"]
pub const NVIC_PRIO_BITS: u8 = 3;
#[cfg(feature = "rt")]
pub use self::Interrupt as interrupt;
pub use cortex_m::peripheral::Peripherals as CorePeripherals;
pub use cortex_m::peripheral::{CBP, CPUID, DCB, DWT, FPB, FPU, ITM, MPU, NVIC, SCB, SYST, TPIU};
#[cfg(feature = "rt")]
pub use cortex_m_rt::interrupt;
#[allow(unused_imports)]
use generic::*;
#[doc = r"Common register and bit access and modify traits"]
pub mod generic;
#[cfg(feature = "rt")]
extern "C" {
    fn INT_AON_GPIO_EDGE();
    fn INT_I2C();
    fn INT_RFC_CPE_1();
    fn INT_PKA();
    fn INT_AON_RTC_COMB();
    fn INT_UART0_COMB();
    fn INT_AUX_SWEV0();
    fn INT_SSI0_COMB();
    fn INT_SSI1_COMB();
    fn INT_RFC_CPE_0();
    fn INT_RFC_HW_COMB();
    fn INT_RFC_CMD_ACK();
    fn INT_I2S();
    fn INT_AUX_SWEV1();
    fn INT_WDT();
    fn INT_GPT0A();
    fn INT_GPT0B();
    fn INT_GPT1A();
    fn INT_GPT1B();
    fn INT_GPT2A();
    fn INT_GPT2B();
    fn INT_GPT3A();
    fn INT_GPT3B();
    fn INT_CRYPTO_RESULT_AVAIL();
    fn INT_DMA_DONE_COMB();
    fn INT_DMA_ERR();
    fn INT_FLASH();
    fn INT_SWEV0();
    fn INT_AUX_COMB();
    fn INT_AON_PROG0();
    fn INT_PROG0();
    fn INT_AUX_COMPA();
    fn INT_AUX_ADC();
    fn INT_TRNG();
    fn INT_OSC_COMB();
    fn INT_AUX_TIMER2_EV0();
    fn INT_UART1_COMB();
    fn INT_BATMON_COMB();
    fn INT_SSI2_COMB();
    fn INT_SSI3_COMB();
    fn INT_UART2_COMB();
    fn INT_UART3_COMB();
    fn INT_I2C1();
    fn INT_SWEV1();
    fn INT_SWEV2();
    fn INT_SWEV3();
    fn INT_SWEV4(); 
}
#[doc(hidden)]
pub union Vector {
    _handler: unsafe extern "C" fn(),
    _reserved: u32,
}
#[cfg(feature = "rt")]
#[doc(hidden)]
#[link_section = ".vector_table.interrupts"]
#[no_mangle]
pub static __INTERRUPTS: [Vector; 47] = [
    Vector { _handler: INT_AON_GPIO_EDGE },
    Vector { _handler: INT_I2C },
    Vector { _handler: INT_RFC_CPE_1 },
    Vector { _handler: INT_PKA },
    Vector { _handler: INT_AON_RTC_COMB },
    Vector { _handler: INT_UART0_COMB },
    Vector { _handler: INT_AUX_SWEV0 },
    Vector { _handler: INT_SSI0_COMB },
    Vector { _handler: INT_SSI1_COMB },
    Vector { _handler: INT_RFC_CPE_0 },
    Vector { _handler: INT_RFC_HW_COMB },
    Vector { _handler: INT_RFC_CMD_ACK },
    Vector { _handler: INT_I2S },
    Vector { _handler: INT_AUX_SWEV1 },
    Vector { _handler: INT_WDT },
    Vector { _handler: INT_GPT0A },
    Vector { _handler: INT_GPT0B },
    Vector { _handler: INT_GPT1A },
    Vector { _handler: INT_GPT1B },
    Vector { _handler: INT_GPT2A },
    Vector { _handler: INT_GPT2B },
    Vector { _handler: INT_GPT3A },
    Vector { _handler: INT_GPT3B },
    Vector { _handler: INT_CRYPTO_RESULT_AVAIL },
    Vector { _handler: INT_DMA_DONE_COMB },
    Vector { _handler: INT_DMA_ERR },
    Vector { _handler: INT_FLASH },
    Vector { _handler: INT_SWEV0 },
    Vector { _handler: INT_AUX_COMB },
    Vector { _handler: INT_AON_PROG0 },
    Vector { _handler: INT_PROG0 },
    Vector { _handler: INT_AUX_COMPA },
    Vector { _handler: INT_AUX_ADC },
    Vector { _handler: INT_TRNG },
    Vector { _handler: INT_OSC_COMB },
    Vector { _handler: INT_AUX_TIMER2_EV0 },
    Vector { _handler: INT_UART1_COMB },
    Vector { _handler: INT_BATMON_COMB },
    Vector { _handler: INT_SSI2_COMB },
    Vector { _handler: INT_SSI3_COMB },
    Vector { _handler: INT_UART2_COMB },
    Vector { _handler: INT_UART3_COMB },
    Vector { _handler: INT_I2C1 },
    Vector { _handler: INT_SWEV1 },
    Vector { _handler: INT_SWEV2 },
    Vector { _handler: INT_SWEV3 },
    Vector { _handler: INT_SWEV4 }
];
#[doc = r"Enumeration of all the interrupts."]
#[derive(Copy, Clone, Debug, PartialEq, Eq)]
pub enum Interrupt {}
unsafe impl cortex_m::interrupt::InterruptNumber for Interrupt {
    #[inline(always)]
    fn number(self) -> u16 {
        match self {}
    }
}
#[doc = "Configuration registers controlling analog peripherals of AUX. Registers Fields should be considered static unless otherwise noted (as dynamic)"]
pub struct AUX_ADI4 {
    _marker: PhantomData<*const ()>,
}
unsafe impl Send for AUX_ADI4 {}
impl AUX_ADI4 {
    #[doc = r"Pointer to the register block"]
    pub const PTR: *const aux_adi4::RegisterBlock = 0x400c_b000 as *const _;
    #[doc = r"Return the pointer to the register block"]
    #[inline(always)]
    pub const fn ptr() -> *const aux_adi4::RegisterBlock {
        Self::PTR
    }
}
impl Deref for AUX_ADI4 {
    type Target = aux_adi4::RegisterBlock;
    #[inline(always)]
    fn deref(&self) -> &Self::Target {
        unsafe { &*Self::PTR }
    }
}
impl core::fmt::Debug for AUX_ADI4 {
    fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
        f.debug_struct("AUX_ADI4").finish()
    }
}
#[doc = "Configuration registers controlling analog peripherals of AUX. Registers Fields should be considered static unless otherwise noted (as dynamic)"]
pub mod aux_adi4;
#[doc = "This is the DDI for the digital block that controls all the analog clock oscillators (OSC_DIG) and performs qualification of the clocks generated."]
pub struct AUX_DDI0_OSC {
    _marker: PhantomData<*const ()>,
}
unsafe impl Send for AUX_DDI0_OSC {}
impl AUX_DDI0_OSC {
    #[doc = r"Pointer to the register block"]
    pub const PTR: *const aux_ddi0_osc::RegisterBlock = 0x580c_a000 as *const _;
    #[doc = r"Return the pointer to the register block"]
    #[inline(always)]
    pub const fn ptr() -> *const aux_ddi0_osc::RegisterBlock {
        Self::PTR
    }
}
impl Deref for AUX_DDI0_OSC {
    type Target = aux_ddi0_osc::RegisterBlock;
    #[inline(always)]
    fn deref(&self) -> &Self::Target {
        unsafe { &*Self::PTR }
    }
}
impl core::fmt::Debug for AUX_DDI0_OSC {
    fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
        f.debug_struct("AUX_DDI0_OSC").finish()
    }
}
#[doc = "This is the DDI for the digital block that controls all the analog clock oscillators (OSC_DIG) and performs qualification of the clocks generated."]
pub mod aux_ddi0_osc;
#[doc = "Serial Peripheral Interface (SPI) with master and slave capabilities"]
pub struct SPI0 {
    _marker: PhantomData<*const ()>,
}
unsafe impl Send for SPI0 {}
impl SPI0 {
    #[doc = r"Pointer to the register block"]
    pub const PTR: *const spi0::RegisterBlock = 0x4000_0000 as *const _;
    #[doc = r"Return the pointer to the register block"]
    #[inline(always)]
    pub const fn ptr() -> *const spi0::RegisterBlock {
        Self::PTR
    }
}
impl Deref for SPI0 {
    type Target = spi0::RegisterBlock;
    #[inline(always)]
    fn deref(&self) -> &Self::Target {
        unsafe { &*Self::PTR }
    }
}
impl core::fmt::Debug for SPI0 {
    fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
        f.debug_struct("SPI0").finish()
    }
}
#[doc = "Serial Peripheral Interface (SPI) with master and slave capabilities"]
pub mod spi0;
#[doc = "Universal Asynchronous Receiver/Transmitter (UART) interface"]
pub struct UART0 {
    _marker: PhantomData<*const ()>,
}
unsafe impl Send for UART0 {}
impl UART0 {
    #[doc = r"Pointer to the register block"]
    pub const PTR: *const uart0::RegisterBlock = 0x4000_1000 as *const _;
    #[doc = r"Return the pointer to the register block"]
    #[inline(always)]
    pub const fn ptr() -> *const uart0::RegisterBlock {
        Self::PTR
    }
}
impl Deref for UART0 {
    type Target = uart0::RegisterBlock;
    #[inline(always)]
    fn deref(&self) -> &Self::Target {
        unsafe { &*Self::PTR }
    }
}
impl core::fmt::Debug for UART0 {
    fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
        f.debug_struct("UART0").finish()
    }
}
#[doc = "Universal Asynchronous Receiver/Transmitter (UART) interface"]
pub mod uart0;
#[doc = "I2CMaster/Slave Serial Controler"]
pub struct I2C0 {
    _marker: PhantomData<*const ()>,
}
unsafe impl Send for I2C0 {}
impl I2C0 {
    #[doc = r"Pointer to the register block"]
    pub const PTR: *const i2c0::RegisterBlock = 0x4000_2000 as *const _;
    #[doc = r"Return the pointer to the register block"]
    #[inline(always)]
    pub const fn ptr() -> *const i2c0::RegisterBlock {
        Self::PTR
    }
}
impl Deref for I2C0 {
    type Target = i2c0::RegisterBlock;
    #[inline(always)]
    fn deref(&self) -> &Self::Target {
        unsafe { &*Self::PTR }
    }
}
impl core::fmt::Debug for I2C0 {
    fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
        f.debug_struct("I2C0").finish()
    }
}
#[doc = "I2CMaster/Slave Serial Controler"]
pub mod i2c0;
#[doc = "Serial Peripheral Interface (SPI) with master and slave capabilities"]
pub struct SPI1 {
    _marker: PhantomData<*const ()>,
}
unsafe impl Send for SPI1 {}
impl SPI1 {
    #[doc = r"Pointer to the register block"]
    pub const PTR: *const spi1::RegisterBlock = 0x4000_8000 as *const _;
    #[doc = r"Return the pointer to the register block"]
    #[inline(always)]
    pub const fn ptr() -> *const spi1::RegisterBlock {
        Self::PTR
    }
}
impl Deref for SPI1 {
    type Target = spi1::RegisterBlock;
    #[inline(always)]
    fn deref(&self) -> &Self::Target {
        unsafe { &*Self::PTR }
    }
}
impl core::fmt::Debug for SPI1 {
    fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
        f.debug_struct("SPI1").finish()
    }
}
#[doc = "Serial Peripheral Interface (SPI) with master and slave capabilities"]
pub mod spi1;
#[doc = "Serial Peripheral Interface (SPI) with master and slave capabilities"]
pub struct SPI2 {
    _marker: PhantomData<*const ()>,
}
unsafe impl Send for SPI2 {}
impl SPI2 {
    #[doc = r"Pointer to the register block"]
    pub const PTR: *const spi2::RegisterBlock = 0x4000_9000 as *const _;
    #[doc = r"Return the pointer to the register block"]
    #[inline(always)]
    pub const fn ptr() -> *const spi2::RegisterBlock {
        Self::PTR
    }
}
impl Deref for SPI2 {
    type Target = spi2::RegisterBlock;
    #[inline(always)]
    fn deref(&self) -> &Self::Target {
        unsafe { &*Self::PTR }
    }
}
impl core::fmt::Debug for SPI2 {
    fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
        f.debug_struct("SPI2").finish()
    }
}
#[doc = "Serial Peripheral Interface (SPI) with master and slave capabilities"]
pub mod spi2;
#[doc = "Serial Peripheral Interface (SPI) with master and slave capabilities"]
pub struct SPI3 {
    _marker: PhantomData<*const ()>,
}
unsafe impl Send for SPI3 {}
impl SPI3 {
    #[doc = r"Pointer to the register block"]
    pub const PTR: *const spi3::RegisterBlock = 0x4000_a000 as *const _;
    #[doc = r"Return the pointer to the register block"]
    #[inline(always)]
    pub const fn ptr() -> *const spi3::RegisterBlock {
        Self::PTR
    }
}
impl Deref for SPI3 {
    type Target = spi3::RegisterBlock;
    #[inline(always)]
    fn deref(&self) -> &Self::Target {
        unsafe { &*Self::PTR }
    }
}
impl core::fmt::Debug for SPI3 {
    fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
        f.debug_struct("SPI3").finish()
    }
}
#[doc = "Serial Peripheral Interface (SPI) with master and slave capabilities"]
pub mod spi3;
#[doc = "Universal Asynchronous Receiver/Transmitter (UART) interface"]
pub struct UART1 {
    _marker: PhantomData<*const ()>,
}
unsafe impl Send for UART1 {}
impl UART1 {
    #[doc = r"Pointer to the register block"]
    pub const PTR: *const uart1::RegisterBlock = 0x4000_b000 as *const _;
    #[doc = r"Return the pointer to the register block"]
    #[inline(always)]
    pub const fn ptr() -> *const uart1::RegisterBlock {
        Self::PTR
    }
}
impl Deref for UART1 {
    type Target = uart1::RegisterBlock;
    #[inline(always)]
    fn deref(&self) -> &Self::Target {
        unsafe { &*Self::PTR }
    }
}
impl core::fmt::Debug for UART1 {
    fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
        f.debug_struct("UART1").finish()
    }
}
#[doc = "Universal Asynchronous Receiver/Transmitter (UART) interface"]
pub mod uart1;
#[doc = "Universal Asynchronous Receiver/Transmitter (UART) interface"]
pub struct UART2 {
    _marker: PhantomData<*const ()>,
}
unsafe impl Send for UART2 {}
impl UART2 {
    #[doc = r"Pointer to the register block"]
    pub const PTR: *const uart2::RegisterBlock = 0x4000_c000 as *const _;
    #[doc = r"Return the pointer to the register block"]
    #[inline(always)]
    pub const fn ptr() -> *const uart2::RegisterBlock {
        Self::PTR
    }
}
impl Deref for UART2 {
    type Target = uart2::RegisterBlock;
    #[inline(always)]
    fn deref(&self) -> &Self::Target {
        unsafe { &*Self::PTR }
    }
}
impl core::fmt::Debug for UART2 {
    fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
        f.debug_struct("UART2").finish()
    }
}
#[doc = "Universal Asynchronous Receiver/Transmitter (UART) interface"]
pub mod uart2;
#[doc = "Universal Asynchronous Receiver/Transmitter (UART) interface"]
pub struct UART3 {
    _marker: PhantomData<*const ()>,
}
unsafe impl Send for UART3 {}
impl UART3 {
    #[doc = r"Pointer to the register block"]
    pub const PTR: *const uart3::RegisterBlock = 0x4000_d000 as *const _;
    #[doc = r"Return the pointer to the register block"]
    #[inline(always)]
    pub const fn ptr() -> *const uart3::RegisterBlock {
        Self::PTR
    }
}
impl Deref for UART3 {
    type Target = uart3::RegisterBlock;
    #[inline(always)]
    fn deref(&self) -> &Self::Target {
        unsafe { &*Self::PTR }
    }
}
impl core::fmt::Debug for UART3 {
    fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
        f.debug_struct("UART3").finish()
    }
}
#[doc = "Universal Asynchronous Receiver/Transmitter (UART) interface"]
pub mod uart3;
#[doc = "General Purpose Timer."]
pub struct GPT0 {
    _marker: PhantomData<*const ()>,
}
unsafe impl Send for GPT0 {}
impl GPT0 {
    #[doc = r"Pointer to the register block"]
    pub const PTR: *const gpt0::RegisterBlock = 0x4001_0000 as *const _;
    #[doc = r"Return the pointer to the register block"]
    #[inline(always)]
    pub const fn ptr() -> *const gpt0::RegisterBlock {
        Self::PTR
    }
}
impl Deref for GPT0 {
    type Target = gpt0::RegisterBlock;
    #[inline(always)]
    fn deref(&self) -> &Self::Target {
        unsafe { &*Self::PTR }
    }
}
impl core::fmt::Debug for GPT0 {
    fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
        f.debug_struct("GPT0").finish()
    }
}
#[doc = "General Purpose Timer."]
pub mod gpt0;
#[doc = "General Purpose Timer."]
pub struct GPT1 {
    _marker: PhantomData<*const ()>,
}
unsafe impl Send for GPT1 {}
impl GPT1 {
    #[doc = r"Pointer to the register block"]
    pub const PTR: *const gpt1::RegisterBlock = 0x4001_1000 as *const _;
    #[doc = r"Return the pointer to the register block"]
    #[inline(always)]
    pub const fn ptr() -> *const gpt1::RegisterBlock {
        Self::PTR
    }
}
impl Deref for GPT1 {
    type Target = gpt1::RegisterBlock;
    #[inline(always)]
    fn deref(&self) -> &Self::Target {
        unsafe { &*Self::PTR }
    }
}
impl core::fmt::Debug for GPT1 {
    fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
        f.debug_struct("GPT1").finish()
    }
}
#[doc = "General Purpose Timer."]
pub mod gpt1;
#[doc = "General Purpose Timer."]
pub struct GPT2 {
    _marker: PhantomData<*const ()>,
}
unsafe impl Send for GPT2 {}
impl GPT2 {
    #[doc = r"Pointer to the register block"]
    pub const PTR: *const gpt2::RegisterBlock = 0x4001_2000 as *const _;
    #[doc = r"Return the pointer to the register block"]
    #[inline(always)]
    pub const fn ptr() -> *const gpt2::RegisterBlock {
        Self::PTR
    }
}
impl Deref for GPT2 {
    type Target = gpt2::RegisterBlock;
    #[inline(always)]
    fn deref(&self) -> &Self::Target {
        unsafe { &*Self::PTR }
    }
}
impl core::fmt::Debug for GPT2 {
    fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
        f.debug_struct("GPT2").finish()
    }
}
#[doc = "General Purpose Timer."]
pub mod gpt2;
#[doc = "General Purpose Timer."]
pub struct GPT3 {
    _marker: PhantomData<*const ()>,
}
unsafe impl Send for GPT3 {}
impl GPT3 {
    #[doc = r"Pointer to the register block"]
    pub const PTR: *const gpt3::RegisterBlock = 0x4001_3000 as *const _;
    #[doc = r"Return the pointer to the register block"]
    #[inline(always)]
    pub const fn ptr() -> *const gpt3::RegisterBlock {
        Self::PTR
    }
}
impl Deref for GPT3 {
    type Target = gpt3::RegisterBlock;
    #[inline(always)]
    fn deref(&self) -> &Self::Target {
        unsafe { &*Self::PTR }
    }
}
impl core::fmt::Debug for GPT3 {
    fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
        f.debug_struct("GPT3").finish()
    }
}
#[doc = "General Purpose Timer."]
pub mod gpt3;
#[doc = "ARM Micro Direct Memory Access Controller"]
pub struct UDMA0 {
    _marker: PhantomData<*const ()>,
}
unsafe impl Send for UDMA0 {}
impl UDMA0 {
    #[doc = r"Pointer to the register block"]
    pub const PTR: *const udma0::RegisterBlock = 0x4002_0000 as *const _;
    #[doc = r"Return the pointer to the register block"]
    #[inline(always)]
    pub const fn ptr() -> *const udma0::RegisterBlock {
        Self::PTR
    }
}
impl Deref for UDMA0 {
    type Target = udma0::RegisterBlock;
    #[inline(always)]
    fn deref(&self) -> &Self::Target {
        unsafe { &*Self::PTR }
    }
}
impl core::fmt::Debug for UDMA0 {
    fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
        f.debug_struct("UDMA0").finish()
    }
}
#[doc = "ARM Micro Direct Memory Access Controller"]
pub mod udma0;
#[doc = "I2S Audio DMA module supporting formats I2S, LJF, RJF and DSP"]
pub struct I2S0 {
    _marker: PhantomData<*const ()>,
}
unsafe impl Send for I2S0 {}
impl I2S0 {
    #[doc = r"Pointer to the register block"]
    pub const PTR: *const i2s0::RegisterBlock = 0x4002_1000 as *const _;
    #[doc = r"Return the pointer to the register block"]
    #[inline(always)]
    pub const fn ptr() -> *const i2s0::RegisterBlock {
        Self::PTR
    }
}
impl Deref for I2S0 {
    type Target = i2s0::RegisterBlock;
    #[inline(always)]
    fn deref(&self) -> &Self::Target {
        unsafe { &*Self::PTR }
    }
}
impl core::fmt::Debug for I2S0 {
    fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
        f.debug_struct("I2S0").finish()
    }
}
#[doc = "I2S Audio DMA module supporting formats I2S, LJF, RJF and DSP"]
pub mod i2s0;
#[doc = "MCU GPIO - I/F for controlling and reading IO status and IO event status"]
pub struct GPIO {
    _marker: PhantomData<*const ()>,
}
unsafe impl Send for GPIO {}
impl GPIO {
    #[doc = r"Pointer to the register block"]
    pub const PTR: *const gpio::RegisterBlock = 0x4002_2000 as *const _;
    #[doc = r"Return the pointer to the register block"]
    #[inline(always)]
    pub const fn ptr() -> *const gpio::RegisterBlock {
        Self::PTR
    }
}
impl Deref for GPIO {
    type Target = gpio::RegisterBlock;
    #[inline(always)]
    fn deref(&self) -> &Self::Target {
        unsafe { &*Self::PTR }
    }
}
impl core::fmt::Debug for GPIO {
    fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
        f.debug_struct("GPIO").finish()
    }
}
#[doc = "MCU GPIO - I/F for controlling and reading IO status and IO event status"]
pub mod gpio;
#[doc = "I2CMaster/Slave Serial Controler"]
pub struct I2C1 {
    _marker: PhantomData<*const ()>,
}
unsafe impl Send for I2C1 {}
impl I2C1 {
    #[doc = r"Pointer to the register block"]
    pub const PTR: *const i2c1::RegisterBlock = 0x4002_a000 as *const _;
    #[doc = r"Return the pointer to the register block"]
    #[inline(always)]
    pub const fn ptr() -> *const i2c1::RegisterBlock {
        Self::PTR
    }
}
impl Deref for I2C1 {
    type Target = i2c1::RegisterBlock;
    #[inline(always)]
    fn deref(&self) -> &Self::Target {
        unsafe { &*Self::PTR }
    }
}
impl core::fmt::Debug for I2C1 {
    fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
        f.debug_struct("I2C1").finish()
    }
}
#[doc = "I2CMaster/Slave Serial Controler"]
pub mod i2c1;
#[doc = "Versatile Instruction Memory System Controls memory access to the Flash and encapsulates the following instruction memories: - Boot ROM - Cache / GPRAM"]
pub struct VIMS {
    _marker: PhantomData<*const ()>,
}
unsafe impl Send for VIMS {}
impl VIMS {
    #[doc = r"Pointer to the register block"]
    pub const PTR: *const vims::RegisterBlock = 0x4003_4000 as *const _;
    #[doc = r"Return the pointer to the register block"]
    #[inline(always)]
    pub const fn ptr() -> *const vims::RegisterBlock {
        Self::PTR
    }
}
impl Deref for VIMS {
    type Target = vims::RegisterBlock;
    #[inline(always)]
    fn deref(&self) -> &Self::Target {
        unsafe { &*Self::PTR }
    }
}
impl core::fmt::Debug for VIMS {
    fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
        f.debug_struct("VIMS").finish()
    }
}
#[doc = "Versatile Instruction Memory System Controls memory access to the Flash and encapsulates the following instruction memories: - Boot ROM - Cache / GPRAM"]
pub mod vims;
#[doc = "RF core power management This module contains clock control for all RF core sub-modules."]
pub struct RFC_PWR {
    _marker: PhantomData<*const ()>,
}
unsafe impl Send for RFC_PWR {}
impl RFC_PWR {
    #[doc = r"Pointer to the register block"]
    pub const PTR: *const rfc_pwr::RegisterBlock = 0x4004_0000 as *const _;
    #[doc = r"Return the pointer to the register block"]
    #[inline(always)]
    pub const fn ptr() -> *const rfc_pwr::RegisterBlock {
        Self::PTR
    }
}
impl Deref for RFC_PWR {
    type Target = rfc_pwr::RegisterBlock;
    #[inline(always)]
    fn deref(&self) -> &Self::Target {
        unsafe { &*Self::PTR }
    }
}
impl core::fmt::Debug for RFC_PWR {
    fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
        f.debug_struct("RFC_PWR").finish()
    }
}
#[doc = "RF core power management This module contains clock control for all RF core sub-modules."]
pub mod rfc_pwr;
#[doc = "RF core doorbell The doorbell module is the main user interface to the radio sub-system. It contains the registers used for both submitting commands to the radio, and for configuring radio interrupts from the RF core."]
pub struct RFC_DBELL {
    _marker: PhantomData<*const ()>,
}
unsafe impl Send for RFC_DBELL {}
impl RFC_DBELL {
    #[doc = r"Pointer to the register block"]
    pub const PTR: *const rfc_dbell::RegisterBlock = 0x4004_1000 as *const _;
    #[doc = r"Return the pointer to the register block"]
    #[inline(always)]
    pub const fn ptr() -> *const rfc_dbell::RegisterBlock {
        Self::PTR
    }
}
impl Deref for RFC_DBELL {
    type Target = rfc_dbell::RegisterBlock;
    #[inline(always)]
    fn deref(&self) -> &Self::Target {
        unsafe { &*Self::PTR }
    }
}
impl core::fmt::Debug for RFC_DBELL {
    fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
        f.debug_struct("RFC_DBELL").finish()
    }
}
#[doc = "RF core doorbell The doorbell module is the main user interface to the radio sub-system. It contains the registers used for both submitting commands to the radio, and for configuring radio interrupts from the RF core."]
pub mod rfc_dbell;
#[doc = "RF core radio timer"]
pub struct RFC_RAT {
    _marker: PhantomData<*const ()>,
}
unsafe impl Send for RFC_RAT {}
impl RFC_RAT {
    #[doc = r"Pointer to the register block"]
    pub const PTR: *const rfc_rat::RegisterBlock = 0x4004_3000 as *const _;
    #[doc = r"Return the pointer to the register block"]
    #[inline(always)]
    pub const fn ptr() -> *const rfc_rat::RegisterBlock {
        Self::PTR
    }
}
impl Deref for RFC_RAT {
    type Target = rfc_rat::RegisterBlock;
    #[inline(always)]
    fn deref(&self) -> &Self::Target {
        unsafe { &*Self::PTR }
    }
}
impl core::fmt::Debug for RFC_RAT {
    fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
        f.debug_struct("RFC_RAT").finish()
    }
}
#[doc = "RF core radio timer"]
pub mod rfc_rat;
#[doc = "Watchdog Timer"]
pub struct WDT {
    _marker: PhantomData<*const ()>,
}
unsafe impl Send for WDT {}
impl WDT {
    #[doc = r"Pointer to the register block"]
    pub const PTR: *const wdt::RegisterBlock = 0x4008_0000 as *const _;
    #[doc = r"Return the pointer to the register block"]
    #[inline(always)]
    pub const fn ptr() -> *const wdt::RegisterBlock {
        Self::PTR
    }
}
impl Deref for WDT {
    type Target = wdt::RegisterBlock;
    #[inline(always)]
    fn deref(&self) -> &Self::Target {
        unsafe { &*Self::PTR }
    }
}
impl core::fmt::Debug for WDT {
    fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
        f.debug_struct("WDT").finish()
    }
}
#[doc = "Watchdog Timer"]
pub mod wdt;
#[doc = "IO Controller (IOC) - configures all the DIOs and resides in the MCU domain. Note: Performing a write operation that includes IOC.IOCFGn.PORT_ID, may cause glitches on the IO. This can happen even if the write operation does not actually change the PORT_ID field (i.e. the write operation writes the same value as it already held) . This happens because the write operation triggers activities in the IOC that may, in some cases, cause glitches. To avoid glitches refrain from writing to this field other than when needed to actually change the PORT_ID value. Note that it is possible to write to parts of the IOCFGn register without writing to PORT_ID by using byte oriented writes to the parts of the register that do not contain PORT_ID"]
pub struct IOC {
    _marker: PhantomData<*const ()>,
}
unsafe impl Send for IOC {}
impl IOC {
    #[doc = r"Pointer to the register block"]
    pub const PTR: *const ioc::RegisterBlock = 0x4008_1000 as *const _;
    #[doc = r"Return the pointer to the register block"]
    #[inline(always)]
    pub const fn ptr() -> *const ioc::RegisterBlock {
        Self::PTR
    }
}
impl Deref for IOC {
    type Target = ioc::RegisterBlock;
    #[inline(always)]
    fn deref(&self) -> &Self::Target {
        unsafe { &*Self::PTR }
    }
}
impl core::fmt::Debug for IOC {
    fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
        f.debug_struct("IOC").finish()
    }
}
#[doc = "IO Controller (IOC) - configures all the DIOs and resides in the MCU domain. Note: Performing a write operation that includes IOC.IOCFGn.PORT_ID, may cause glitches on the IO. This can happen even if the write operation does not actually change the PORT_ID field (i.e. the write operation writes the same value as it already held) . This happens because the write operation triggers activities in the IOC that may, in some cases, cause glitches. To avoid glitches refrain from writing to this field other than when needed to actually change the PORT_ID value. Note that it is possible to write to parts of the IOCFGn register without writing to PORT_ID by using byte oriented writes to the parts of the register that do not contain PORT_ID"]
pub mod ioc;
#[doc = "Event Fabric Component Definition"]
pub struct EVENT {
    _marker: PhantomData<*const ()>,
}
unsafe impl Send for EVENT {}
impl EVENT {
    #[doc = r"Pointer to the register block"]
    pub const PTR: *const event::RegisterBlock = 0x4008_3000 as *const _;
    #[doc = r"Return the pointer to the register block"]
    #[inline(always)]
    pub const fn ptr() -> *const event::RegisterBlock {
        Self::PTR
    }
}
impl Deref for EVENT {
    type Target = event::RegisterBlock;
    #[inline(always)]
    fn deref(&self) -> &Self::Target {
        unsafe { &*Self::PTR }
    }
}
impl core::fmt::Debug for EVENT {
    fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
        f.debug_struct("EVENT").finish()
    }
}
#[doc = "Event Fabric Component Definition"]
pub mod event;
#[doc = "MCU Semaphore Module This module provides 32 binary semaphores. The state of a binary semaphore is either taken or available. A semaphore does not implement any ownership attribute. Still, a semaphore can be used to handle mutual exclusion scenarios."]
pub struct SMPH {
    _marker: PhantomData<*const ()>,
}
unsafe impl Send for SMPH {}
impl SMPH {
    #[doc = r"Pointer to the register block"]
    pub const PTR: *const smph::RegisterBlock = 0x4008_4000 as *const _;
    #[doc = r"Return the pointer to the register block"]
    #[inline(always)]
    pub const fn ptr() -> *const smph::RegisterBlock {
        Self::PTR
    }
}
impl Deref for SMPH {
    type Target = smph::RegisterBlock;
    #[inline(always)]
    fn deref(&self) -> &Self::Target {
        unsafe { &*Self::PTR }
    }
}
impl core::fmt::Debug for SMPH {
    fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
        f.debug_struct("SMPH").finish()
    }
}
#[doc = "MCU Semaphore Module This module provides 32 binary semaphores. The state of a binary semaphore is either taken or available. A semaphore does not implement any ownership attribute. Still, a semaphore can be used to handle mutual exclusion scenarios."]
pub mod smph;
#[doc = "This module configures the event fabric located in the AON domain. Note: This module is only supporting 32 bit ReadWrite access from MCU"]
pub struct AON_EVENT {
    _marker: PhantomData<*const ()>,
}
unsafe impl Send for AON_EVENT {}
impl AON_EVENT {
    #[doc = r"Pointer to the register block"]
    pub const PTR: *const aon_event::RegisterBlock = 0x4009_3000 as *const _;
    #[doc = r"Return the pointer to the register block"]
    #[inline(always)]
    pub const fn ptr() -> *const aon_event::RegisterBlock {
        Self::PTR
    }
}
impl Deref for AON_EVENT {
    type Target = aon_event::RegisterBlock;
    #[inline(always)]
    fn deref(&self) -> &Self::Target {
        unsafe { &*Self::PTR }
    }
}
impl core::fmt::Debug for AON_EVENT {
    fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
        f.debug_struct("AON_EVENT").finish()
    }
}
#[doc = "This module configures the event fabric located in the AON domain. Note: This module is only supporting 32 bit ReadWrite access from MCU"]
pub mod aon_event;
#[doc = "Always On (AON) IO Controller - controls IO operation when the MCU IO Controller (IOC) is powered off and resides in the AON domain. Note: This module only supports 32 bit Read/Write access from MCU."]
pub struct AON_IOC {
    _marker: PhantomData<*const ()>,
}
unsafe impl Send for AON_IOC {}
impl AON_IOC {
    #[doc = r"Pointer to the register block"]
    pub const PTR: *const aon_ioc::RegisterBlock = 0x4009_4000 as *const _;
    #[doc = r"Return the pointer to the register block"]
    #[inline(always)]
    pub const fn ptr() -> *const aon_ioc::RegisterBlock {
        Self::PTR
    }
}
impl Deref for AON_IOC {
    type Target = aon_ioc::RegisterBlock;
    #[inline(always)]
    fn deref(&self) -> &Self::Target {
        unsafe { &*Self::PTR }
    }
}
impl core::fmt::Debug for AON_IOC {
    fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
        f.debug_struct("AON_IOC").finish()
    }
}
#[doc = "Always On (AON) IO Controller - controls IO operation when the MCU IO Controller (IOC) is powered off and resides in the AON domain. Note: This module only supports 32 bit Read/Write access from MCU."]
pub mod aon_ioc;
#[doc = "Always On (AON) Battery And Temperature MONitor (BATMON) residing in the AON domain Note: This module only supports 32 bit Read/Write access from MCU."]
pub struct AON_BATMON {
    _marker: PhantomData<*const ()>,
}
unsafe impl Send for AON_BATMON {}
impl AON_BATMON {
    #[doc = r"Pointer to the register block"]
    pub const PTR: *const aon_batmon::RegisterBlock = 0x4009_5000 as *const _;
    #[doc = r"Return the pointer to the register block"]
    #[inline(always)]
    pub const fn ptr() -> *const aon_batmon::RegisterBlock {
        Self::PTR
    }
}
impl Deref for AON_BATMON {
    type Target = aon_batmon::RegisterBlock;
    #[inline(always)]
    fn deref(&self) -> &Self::Target {
        unsafe { &*Self::PTR }
    }
}
impl core::fmt::Debug for AON_BATMON {
    fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
        f.debug_struct("AON_BATMON").finish()
    }
}
#[doc = "Always On (AON) Battery And Temperature MONitor (BATMON) residing in the AON domain Note: This module only supports 32 bit Read/Write access from MCU."]
pub mod aon_batmon;
#[doc = "The AUX Serial Peripheral Interface Master (AUX_SPIM) enables AUX_SCE with power-efficient SPI communication. It is not possible to write a register while SPI transmission occurs. An attempt to do so will stall the bus until transmission is complete. Read of RX8.DATA or RX16.DATA stalls the bus until LSB has been captured. Read of SCLKIDLE.STAT or DATAIDLE.STAT stalls the bus until condition described is met. Other read operations do not stall the bus. AUX_SCE becomes clock gated if it encounters a bus stall. This is useful as AUX_SCE can write TX8.DATA and then read RX8.DATA immediately to read a SPI slave. In such case there is no need for software to wait or to poll registers. AUX_SYSIF:PEROPRATE.SPIM_OP_RATE selects the peripheral clock frequency which is used to derive the SCLK frequency. AUX_SCE must set AUX_SYSIF:PEROPRATE.SPIM_OP_RATE to SCE_RATE to access and use AUX_SPIM. System CPU must set AUX_SYSIF:PEROPRATE.SPIM_OP_RATE to BUS_RATE to access and use AUX_SPIM. Failure to do so can result in incorrect SPI transmission."]
pub struct AUX_SPIM {
    _marker: PhantomData<*const ()>,
}
unsafe impl Send for AUX_SPIM {}
impl AUX_SPIM {
    #[doc = r"Pointer to the register block"]
    pub const PTR: *const aux_spim::RegisterBlock = 0x400c_1000 as *const _;
    #[doc = r"Return the pointer to the register block"]
    #[inline(always)]
    pub const fn ptr() -> *const aux_spim::RegisterBlock {
        Self::PTR
    }
}
impl Deref for AUX_SPIM {
    type Target = aux_spim::RegisterBlock;
    #[inline(always)]
    fn deref(&self) -> &Self::Target {
        unsafe { &*Self::PTR }
    }
}
impl core::fmt::Debug for AUX_SPIM {
    fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
        f.debug_struct("AUX_SPIM").finish()
    }
}
#[doc = "The AUX Serial Peripheral Interface Master (AUX_SPIM) enables AUX_SCE with power-efficient SPI communication. It is not possible to write a register while SPI transmission occurs. An attempt to do so will stall the bus until transmission is complete. Read of RX8.DATA or RX16.DATA stalls the bus until LSB has been captured. Read of SCLKIDLE.STAT or DATAIDLE.STAT stalls the bus until condition described is met. Other read operations do not stall the bus. AUX_SCE becomes clock gated if it encounters a bus stall. This is useful as AUX_SCE can write TX8.DATA and then read RX8.DATA immediately to read a SPI slave. In such case there is no need for software to wait or to poll registers. AUX_SYSIF:PEROPRATE.SPIM_OP_RATE selects the peripheral clock frequency which is used to derive the SCLK frequency. AUX_SCE must set AUX_SYSIF:PEROPRATE.SPIM_OP_RATE to SCE_RATE to access and use AUX_SPIM. System CPU must set AUX_SYSIF:PEROPRATE.SPIM_OP_RATE to BUS_RATE to access and use AUX_SPIM. Failure to do so can result in incorrect SPI transmission."]
pub mod aux_spim;
#[doc = "The AUX Multiply-Accumulate (AUX_MAC) peripheral enables AUX_SCE with power-efficient and flexible mathematical operations: - 2's complement signed and unsigned sequential multiplication (MUL) with optional accumulation of the result (MAC). - 16 or 32-bit 2's complement signed and unsigned addition of configurable term and accumulator (ADD). - Results of ADD, MUL and MAC operations are always stored in the accumulator (ACC). Software can easily: - Access arbitrary 16-bit slice of the 40-bit accumulator. - Find the number of leading zero or sign bits. - Perform shift operations on the accumulator. AUX_SCE must set AUX_SYSIF:PEROPRATE.MAC_OP_RATE to SCE_RATE to access and use AUX_MAC. System CPU must set AUX_SYSIF:PEROPRATE.MAC_OP_RATE to BUS_RATE to access and use AUX_MAC. This guarantees constant execution times for ADD, MUL, and MAC operations. The ADD operation requires a single peripheral clock cycle to finish. MUL and MAC operations require four peripheral clock periods to finish. An unfinished ADD, MUL, or MAC operation stalls register access to this peripheral. AUX_SCE becomes clock gated if it encounters a bus stall. Software can use this to reduce power consumption during back to back accesses. Only full word access is supported by the peripheral. An attempt to write a single byte will have no effect."]
pub struct AUX_MAC {
    _marker: PhantomData<*const ()>,
}
unsafe impl Send for AUX_MAC {}
impl AUX_MAC {
    #[doc = r"Pointer to the register block"]
    pub const PTR: *const aux_mac::RegisterBlock = 0x400c_2000 as *const _;
    #[doc = r"Return the pointer to the register block"]
    #[inline(always)]
    pub const fn ptr() -> *const aux_mac::RegisterBlock {
        Self::PTR
    }
}
impl Deref for AUX_MAC {
    type Target = aux_mac::RegisterBlock;
    #[inline(always)]
    fn deref(&self) -> &Self::Target {
        unsafe { &*Self::PTR }
    }
}
impl core::fmt::Debug for AUX_MAC {
    fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
        f.debug_struct("AUX_MAC").finish()
    }
}
#[doc = "The AUX Multiply-Accumulate (AUX_MAC) peripheral enables AUX_SCE with power-efficient and flexible mathematical operations: - 2's complement signed and unsigned sequential multiplication (MUL) with optional accumulation of the result (MAC). - 16 or 32-bit 2's complement signed and unsigned addition of configurable term and accumulator (ADD). - Results of ADD, MUL and MAC operations are always stored in the accumulator (ACC). Software can easily: - Access arbitrary 16-bit slice of the 40-bit accumulator. - Find the number of leading zero or sign bits. - Perform shift operations on the accumulator. AUX_SCE must set AUX_SYSIF:PEROPRATE.MAC_OP_RATE to SCE_RATE to access and use AUX_MAC. System CPU must set AUX_SYSIF:PEROPRATE.MAC_OP_RATE to BUS_RATE to access and use AUX_MAC. This guarantees constant execution times for ADD, MUL, and MAC operations. The ADD operation requires a single peripheral clock cycle to finish. MUL and MAC operations require four peripheral clock periods to finish. An unfinished ADD, MUL, or MAC operation stalls register access to this peripheral. AUX_SCE becomes clock gated if it encounters a bus stall. Software can use this to reduce power consumption during back to back accesses. Only full word access is supported by the peripheral. An attempt to write a single byte will have no effect."]
pub mod aux_mac;
#[doc = "AUX Timer2 (AUX_TIMER2) offers flexible: - generation of waveforms and events. - capture of signal period and duty cycle. - generation of single clock pulse. It consists of a: - 16-bit counter. - 4 capture compare channels. - 4 event outputs, which are mapped to AUX event bus, see EVCTL. Each channel subscribes to the asynchronous AUX event bus. They can control one or more event outputs in both capture and compare modes. AUX_SYSIF:TIMER2CLKCTL.SRC selects clock source for the timer."]
pub struct AUX_TIMER2 {
    _marker: PhantomData<*const ()>,
}
unsafe impl Send for AUX_TIMER2 {}
impl AUX_TIMER2 {
    #[doc = r"Pointer to the register block"]
    pub const PTR: *const aux_timer2::RegisterBlock = 0x400c_3000 as *const _;
    #[doc = r"Return the pointer to the register block"]
    #[inline(always)]
    pub const fn ptr() -> *const aux_timer2::RegisterBlock {
        Self::PTR
    }
}
impl Deref for AUX_TIMER2 {
    type Target = aux_timer2::RegisterBlock;
    #[inline(always)]
    fn deref(&self) -> &Self::Target {
        unsafe { &*Self::PTR }
    }
}
impl core::fmt::Debug for AUX_TIMER2 {
    fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
        f.debug_struct("AUX_TIMER2").finish()
    }
}
#[doc = "AUX Timer2 (AUX_TIMER2) offers flexible: - generation of waveforms and events. - capture of signal period and duty cycle. - generation of single clock pulse. It consists of a: - 16-bit counter. - 4 capture compare channels. - 4 event outputs, which are mapped to AUX event bus, see EVCTL. Each channel subscribes to the asynchronous AUX event bus. They can control one or more event outputs in both capture and compare modes. AUX_SYSIF:TIMER2CLKCTL.SRC selects clock source for the timer."]
pub mod aux_timer2;
#[doc = "AUX Time To Digital Converter (AUX_TDC) is used to measure the time between two events with high resolution. AUX_TDC consists of a state machine that operates at AUX bus rate and an asynchronous fast-counter which is clocked by the TDC clock. DDI_0_OSC:CTL0.ACLK_TDC_SRC_SEL configures TDC clock source. The fast-counter counts on both edges of the TDC clock to double the resolution. See the Technical Reference Manual for event timing requirements."]
pub struct AUX_TDC {
    _marker: PhantomData<*const ()>,
}
unsafe impl Send for AUX_TDC {}
impl AUX_TDC {
    #[doc = r"Pointer to the register block"]
    pub const PTR: *const aux_tdc::RegisterBlock = 0x400c_4000 as *const _;
    #[doc = r"Return the pointer to the register block"]
    #[inline(always)]
    pub const fn ptr() -> *const aux_tdc::RegisterBlock {
        Self::PTR
    }
}
impl Deref for AUX_TDC {
    type Target = aux_tdc::RegisterBlock;
    #[inline(always)]
    fn deref(&self) -> &Self::Target {
        unsafe { &*Self::PTR }
    }
}
impl core::fmt::Debug for AUX_TDC {
    fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
        f.debug_struct("AUX_TDC").finish()
    }
}
#[doc = "AUX Time To Digital Converter (AUX_TDC) is used to measure the time between two events with high resolution. AUX_TDC consists of a state machine that operates at AUX bus rate and an asynchronous fast-counter which is clocked by the TDC clock. DDI_0_OSC:CTL0.ACLK_TDC_SRC_SEL configures TDC clock source. The fast-counter counts on both edges of the TDC clock to double the resolution. See the Technical Reference Manual for event timing requirements."]
pub mod aux_tdc;
#[doc = "AUX Event Controller (AUX_EVCTL) assembles events originating from: - AUX submodules, including ADC and comparators. - AUXIO. - EVENT. - AON_PMCTL. - AON_RTC. - AON_BATMON. into two 64-bit event buses. One is synchronized to the AUX clock and one is left unsynchronized. The subscribers to the synchronous event bus are AUX_TIMER01, AUX_SCE and AUX_EVCTL. The subscribers to the asynchronous event bus are AUX_TIMER2, AUX_ANAIF, AUX_TDC and AUX_SYSIF. AUX_EVCTL uses the synchronous event bus to generate events to AON_EVENT and EVENT, as well as to AUX_SCE. AUX_SCE can poll event status registers and combine certain instructions like WEV0, WEV1 with one or two configurable events. The latter saves power when execution must stall until a condition is met."]
pub struct AUX_EVCTL {
    _marker: PhantomData<*const ()>,
}
unsafe impl Send for AUX_EVCTL {}
impl AUX_EVCTL {
    #[doc = r"Pointer to the register block"]
    pub const PTR: *const aux_evctl::RegisterBlock = 0x400c_5000 as *const _;
    #[doc = r"Return the pointer to the register block"]
    #[inline(always)]
    pub const fn ptr() -> *const aux_evctl::RegisterBlock {
        Self::PTR
    }
}
impl Deref for AUX_EVCTL {
    type Target = aux_evctl::RegisterBlock;
    #[inline(always)]
    fn deref(&self) -> &Self::Target {
        unsafe { &*Self::PTR }
    }
}
impl core::fmt::Debug for AUX_EVCTL {
    fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
        f.debug_struct("AUX_EVCTL").finish()
    }
}
#[doc = "AUX Event Controller (AUX_EVCTL) assembles events originating from: - AUX submodules, including ADC and comparators. - AUXIO. - EVENT. - AON_PMCTL. - AON_RTC. - AON_BATMON. into two 64-bit event buses. One is synchronized to the AUX clock and one is left unsynchronized. The subscribers to the synchronous event bus are AUX_TIMER01, AUX_SCE and AUX_EVCTL. The subscribers to the asynchronous event bus are AUX_TIMER2, AUX_ANAIF, AUX_TDC and AUX_SYSIF. AUX_EVCTL uses the synchronous event bus to generate events to AON_EVENT and EVENT, as well as to AUX_SCE. AUX_SCE can poll event status registers and combine certain instructions like WEV0, WEV1 with one or two configurable events. The latter saves power when execution must stall until a condition is met."]
pub mod aux_evctl;
#[doc = "AUX Timer 0 and AUX Timer 1 (AUX_TIMER01) are two 16-bit timers capable of generating one event each: - AUX_EVCTL:EVSTAT3.AUX_TIMER0_EV. - AUX_EVCTL:EVSTAT3.AUX_TIMER1_EV. The events are described in T0TARGET and T1TARGET. Subscribers to the AUX event bus can use these events to sequence and trigger actions. AUX_SYSIF:PEROPRATE.TIMER01_OP_RATE sets the peripheral clock frequency used by the prescaler, timer, and event logic to SCE or AUX bus rate. To use AUX_TIMER01: - AUX_SCE must set AUX_SYSIF:PEROPRATE.TIMER01_OP_RATE to SCE_RATE. - System CPU must set AUX_SYSIF:PEROPRATE.TIMER01_OP_RATE to BUS_RATE. - The timers must only subscribe to events updated at the peripheral clock frequency or lower. Unexpected execution behavior can result if software does not obey these rules."]
pub struct AUX_TIMER01 {
    _marker: PhantomData<*const ()>,
}
unsafe impl Send for AUX_TIMER01 {}
impl AUX_TIMER01 {
    #[doc = r"Pointer to the register block"]
    pub const PTR: *const aux_timer01::RegisterBlock = 0x400c_7000 as *const _;
    #[doc = r"Return the pointer to the register block"]
    #[inline(always)]
    pub const fn ptr() -> *const aux_timer01::RegisterBlock {
        Self::PTR
    }
}
impl Deref for AUX_TIMER01 {
    type Target = aux_timer01::RegisterBlock;
    #[inline(always)]
    fn deref(&self) -> &Self::Target {
        unsafe { &*Self::PTR }
    }
}
impl core::fmt::Debug for AUX_TIMER01 {
    fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
        f.debug_struct("AUX_TIMER01").finish()
    }
}
#[doc = "AUX Timer 0 and AUX Timer 1 (AUX_TIMER01) are two 16-bit timers capable of generating one event each: - AUX_EVCTL:EVSTAT3.AUX_TIMER0_EV. - AUX_EVCTL:EVSTAT3.AUX_TIMER1_EV. The events are described in T0TARGET and T1TARGET. Subscribers to the AUX event bus can use these events to sequence and trigger actions. AUX_SYSIF:PEROPRATE.TIMER01_OP_RATE sets the peripheral clock frequency used by the prescaler, timer, and event logic to SCE or AUX bus rate. To use AUX_TIMER01: - AUX_SCE must set AUX_SYSIF:PEROPRATE.TIMER01_OP_RATE to SCE_RATE. - System CPU must set AUX_SYSIF:PEROPRATE.TIMER01_OP_RATE to BUS_RATE. - The timers must only subscribe to events updated at the peripheral clock frequency or lower. Unexpected execution behavior can result if software does not obey these rules."]
pub mod aux_timer01;
#[doc = "AUX Semaphore (AUX_SMPH) provides hardware means to share modules in AUX safely between CPUs based on resource ownership. AUX_SMPH operates at AUX bus rate."]
pub struct AUX_SMPH {
    _marker: PhantomData<*const ()>,
}
unsafe impl Send for AUX_SMPH {}
impl AUX_SMPH {
    #[doc = r"Pointer to the register block"]
    pub const PTR: *const aux_smph::RegisterBlock = 0x400c_8000 as *const _;
    #[doc = r"Return the pointer to the register block"]
    #[inline(always)]
    pub const fn ptr() -> *const aux_smph::RegisterBlock {
        Self::PTR
    }
}
impl Deref for AUX_SMPH {
    type Target = aux_smph::RegisterBlock;
    #[inline(always)]
    fn deref(&self) -> &Self::Target {
        unsafe { &*Self::PTR }
    }
}
impl core::fmt::Debug for AUX_SMPH {
    fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
        f.debug_struct("AUX_SMPH").finish()
    }
}
#[doc = "AUX Semaphore (AUX_SMPH) provides hardware means to share modules in AUX safely between CPUs based on resource ownership. AUX_SMPH operates at AUX bus rate."]
pub mod aux_smph;
#[doc = "AUX Analog Interface (AUX_ANAIF) encapsulates direct data and control interfaces between AUX digital and AUX analog circuits. It lets UDMA0, and system CPU: -Trigger ADC sample and conversion process. - Write ADC samples to FIFO. - Charge analog nodes by the use of the analog ISRC module. See ADI_4_AUX:ISRC and ADI_4_AUX:COMP.COMPA_REF_CURR_EN for further information. - Use the DAC to generate a programmable voltage on COMPB_REF, COMPA_REF, or COMPA_IN analog nodes. To use: - DAC : System CPU must set AUX_SYSIF:PEROPRATE.ANAIF_DAC_OP_RATE to BUS_RATE as long as DAC state machine generates the sample clock. See DACSMPLCTL.EN for further information."]
pub struct AUX_ANAIF {
    _marker: PhantomData<*const ()>,
}
unsafe impl Send for AUX_ANAIF {}
impl AUX_ANAIF {
    #[doc = r"Pointer to the register block"]
    pub const PTR: *const aux_anaif::RegisterBlock = 0x400c_9000 as *const _;
    #[doc = r"Return the pointer to the register block"]
    #[inline(always)]
    pub const fn ptr() -> *const aux_anaif::RegisterBlock {
        Self::PTR
    }
}
impl Deref for AUX_ANAIF {
    type Target = aux_anaif::RegisterBlock;
    #[inline(always)]
    fn deref(&self) -> &Self::Target {
        unsafe { &*Self::PTR }
    }
}
impl core::fmt::Debug for AUX_ANAIF {
    fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
        f.debug_struct("AUX_ANAIF").finish()
    }
}
#[doc = "AUX Analog Interface (AUX_ANAIF) encapsulates direct data and control interfaces between AUX digital and AUX analog circuits. It lets UDMA0, and system CPU: -Trigger ADC sample and conversion process. - Write ADC samples to FIFO. - Charge analog nodes by the use of the analog ISRC module. See ADI_4_AUX:ISRC and ADI_4_AUX:COMP.COMPA_REF_CURR_EN for further information. - Use the DAC to generate a programmable voltage on COMPB_REF, COMPA_REF, or COMPA_IN analog nodes. To use: - DAC : System CPU must set AUX_SYSIF:PEROPRATE.ANAIF_DAC_OP_RATE to BUS_RATE as long as DAC state machine generates the sample clock. See DACSMPLCTL.EN for further information."]
pub mod aux_anaif;
#[doc = "AUX Analog Digital Input Output Controller (AUX_AIODIO) controls the general purpose input output pins of the AUX domain. These pins are referenced as AUXIO and can: - be connected to analog AUX modules, such as comparators and ADC. - be used by AUX_SCE. - connect to AUX_SPIM SCLK, MISO and MOSI signals. - connect to the asynchronous AUX event bus. Enabled digital inputs are synchronized at SCE clock rate. Note that the IO mapping in the AUX domain is different from the IO mapping in the MCU domain. This means that AUXIO[n]
does not map to DIO[n]. AUXIO-DIO remapping is handled by Sensor Controller Studio."]
pub struct AUX_AIODIO0 {
    _marker: PhantomData<*const ()>,
}
unsafe impl Send for AUX_AIODIO0 {}
impl AUX_AIODIO0 {
    #[doc = r"Pointer to the register block"]
    pub const PTR: *const aux_aiodio0::RegisterBlock = 0x400c_c000 as *const _;
    #[doc = r"Return the pointer to the register block"]
    #[inline(always)]
    pub const fn ptr() -> *const aux_aiodio0::RegisterBlock {
        Self::PTR
    }
}
impl Deref for AUX_AIODIO0 {
    type Target = aux_aiodio0::RegisterBlock;
    #[inline(always)]
    fn deref(&self) -> &Self::Target {
        unsafe { &*Self::PTR }
    }
}
impl core::fmt::Debug for AUX_AIODIO0 {
    fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
        f.debug_struct("AUX_AIODIO0").finish()
    }
}
#[doc = "AUX Analog Digital Input Output Controller (AUX_AIODIO) controls the general purpose input output pins of the AUX domain. These pins are referenced as AUXIO and can: - be connected to analog AUX modules, such as comparators and ADC. - be used by AUX_SCE. - connect to AUX_SPIM SCLK, MISO and MOSI signals. - connect to the asynchronous AUX event bus. Enabled digital inputs are synchronized at SCE clock rate. Note that the IO mapping in the AUX domain is different from the IO mapping in the MCU domain. This means that AUXIO\\[n\\]
does not map to DIO\\[n\\]. AUXIO-DIO remapping is handled by Sensor Controller Studio."]
pub mod aux_aiodio0;
#[doc = "AUX Analog Digital Input Output Controller (AUX_AIODIO) controls the general purpose input output pins of the AUX domain. These pins are referenced as AUXIO and can: - be connected to analog AUX modules, such as comparators and ADC. - be used by AUX_SCE. - connect to AUX_SPIM SCLK, MISO and MOSI signals. - connect to the asynchronous AUX event bus. Enabled digital inputs are synchronized at SCE clock rate. Note that the IO mapping in the AUX domain is different from the IO mapping in the MCU domain. This means that AUXIO[n]
does not map to DIO[n]. AUXIO-DIO remapping is handled by Sensor Controller Studio."]
pub struct AUX_AIODIO1 {
    _marker: PhantomData<*const ()>,
}
unsafe impl Send for AUX_AIODIO1 {}
impl AUX_AIODIO1 {
    #[doc = r"Pointer to the register block"]
    pub const PTR: *const aux_aiodio1::RegisterBlock = 0x400c_d000 as *const _;
    #[doc = r"Return the pointer to the register block"]
    #[inline(always)]
    pub const fn ptr() -> *const aux_aiodio1::RegisterBlock {
        Self::PTR
    }
}
impl Deref for AUX_AIODIO1 {
    type Target = aux_aiodio1::RegisterBlock;
    #[inline(always)]
    fn deref(&self) -> &Self::Target {
        unsafe { &*Self::PTR }
    }
}
impl core::fmt::Debug for AUX_AIODIO1 {
    fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
        f.debug_struct("AUX_AIODIO1").finish()
    }
}
#[doc = "AUX Analog Digital Input Output Controller (AUX_AIODIO) controls the general purpose input output pins of the AUX domain. These pins are referenced as AUXIO and can: - be connected to analog AUX modules, such as comparators and ADC. - be used by AUX_SCE. - connect to AUX_SPIM SCLK, MISO and MOSI signals. - connect to the asynchronous AUX event bus. Enabled digital inputs are synchronized at SCE clock rate. Note that the IO mapping in the AUX domain is different from the IO mapping in the MCU domain. This means that AUXIO\\[n\\]
does not map to DIO\\[n\\]. AUXIO-DIO remapping is handled by Sensor Controller Studio."]
pub mod aux_aiodio1;
#[doc = "AUX Analog Digital Input Output Controller (AUX_AIODIO) controls the general purpose input output pins of the AUX domain. These pins are referenced as AUXIO and can: - be connected to analog AUX modules, such as comparators and ADC. - be used by AUX_SCE. - connect to AUX_SPIM SCLK, MISO and MOSI signals. - connect to the asynchronous AUX event bus. Enabled digital inputs are synchronized at SCE clock rate. Note that the IO mapping in the AUX domain is different from the IO mapping in the MCU domain. This means that AUXIO[n]
does not map to DIO[n]. AUXIO-DIO remapping is handled by Sensor Controller Studio."]
pub struct AUX_AIODIO2 {
    _marker: PhantomData<*const ()>,
}
unsafe impl Send for AUX_AIODIO2 {}
impl AUX_AIODIO2 {
    #[doc = r"Pointer to the register block"]
    pub const PTR: *const aux_aiodio2::RegisterBlock = 0x400c_e000 as *const _;
    #[doc = r"Return the pointer to the register block"]
    #[inline(always)]
    pub const fn ptr() -> *const aux_aiodio2::RegisterBlock {
        Self::PTR
    }
}
impl Deref for AUX_AIODIO2 {
    type Target = aux_aiodio2::RegisterBlock;
    #[inline(always)]
    fn deref(&self) -> &Self::Target {
        unsafe { &*Self::PTR }
    }
}
impl core::fmt::Debug for AUX_AIODIO2 {
    fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
        f.debug_struct("AUX_AIODIO2").finish()
    }
}
#[doc = "AUX Analog Digital Input Output Controller (AUX_AIODIO) controls the general purpose input output pins of the AUX domain. These pins are referenced as AUXIO and can: - be connected to analog AUX modules, such as comparators and ADC. - be used by AUX_SCE. - connect to AUX_SPIM SCLK, MISO and MOSI signals. - connect to the asynchronous AUX event bus. Enabled digital inputs are synchronized at SCE clock rate. Note that the IO mapping in the AUX domain is different from the IO mapping in the MCU domain. This means that AUXIO\\[n\\]
does not map to DIO\\[n\\]. AUXIO-DIO remapping is handled by Sensor Controller Studio."]
pub mod aux_aiodio2;
#[doc = "AUX Analog Digital Input Output Controller (AUX_AIODIO) controls the general purpose input output pins of the AUX domain. These pins are referenced as AUXIO and can: - be connected to analog AUX modules, such as comparators and ADC. - be used by AUX_SCE. - connect to AUX_SPIM SCLK, MISO and MOSI signals. - connect to the asynchronous AUX event bus. Enabled digital inputs are synchronized at SCE clock rate. Note that the IO mapping in the AUX domain is different from the IO mapping in the MCU domain. This means that AUXIO[n]
does not map to DIO[n]. AUXIO-DIO remapping is handled by Sensor Controller Studio."]
pub struct AUX_AIODIO3 {
    _marker: PhantomData<*const ()>,
}
unsafe impl Send for AUX_AIODIO3 {}
impl AUX_AIODIO3 {
    #[doc = r"Pointer to the register block"]
    pub const PTR: *const aux_aiodio3::RegisterBlock = 0x400c_f000 as *const _;
    #[doc = r"Return the pointer to the register block"]
    #[inline(always)]
    pub const fn ptr() -> *const aux_aiodio3::RegisterBlock {
        Self::PTR
    }
}
impl Deref for AUX_AIODIO3 {
    type Target = aux_aiodio3::RegisterBlock;
    #[inline(always)]
    fn deref(&self) -> &Self::Target {
        unsafe { &*Self::PTR }
    }
}
impl core::fmt::Debug for AUX_AIODIO3 {
    fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
        f.debug_struct("AUX_AIODIO3").finish()
    }
}
#[doc = "AUX Analog Digital Input Output Controller (AUX_AIODIO) controls the general purpose input output pins of the AUX domain. These pins are referenced as AUXIO and can: - be connected to analog AUX modules, such as comparators and ADC. - be used by AUX_SCE. - connect to AUX_SPIM SCLK, MISO and MOSI signals. - connect to the asynchronous AUX event bus. Enabled digital inputs are synchronized at SCE clock rate. Note that the IO mapping in the AUX domain is different from the IO mapping in the MCU domain. This means that AUXIO\\[n\\]
does not map to DIO\\[n\\]. AUXIO-DIO remapping is handled by Sensor Controller Studio."]
pub mod aux_aiodio3;
#[doc = "Customer configuration area (CCFG)"]
pub struct CCFG {
    _marker: PhantomData<*const ()>,
}
unsafe impl Send for CCFG {}
impl CCFG {
    #[doc = r"Pointer to the register block"]
    pub const PTR: *const ccfg::RegisterBlock = 0x5000_0000 as *const _;
    #[doc = r"Return the pointer to the register block"]
    #[inline(always)]
    pub const fn ptr() -> *const ccfg::RegisterBlock {
        Self::PTR
    }
}
impl Deref for CCFG {
    type Target = ccfg::RegisterBlock;
    #[inline(always)]
    fn deref(&self) -> &Self::Target {
        unsafe { &*Self::PTR }
    }
}
impl core::fmt::Debug for CCFG {
    fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
        f.debug_struct("CCFG").finish()
    }
}
#[doc = "Customer configuration area (CCFG)"]
pub mod ccfg;
#[doc = "Factory configuration area (FCFG1)"]
pub struct FCFG1 {
    _marker: PhantomData<*const ()>,
}
unsafe impl Send for FCFG1 {}
impl FCFG1 {
    #[doc = r"Pointer to the register block"]
    pub const PTR: *const fcfg1::RegisterBlock = 0x5000_0800 as *const _;
    #[doc = r"Return the pointer to the register block"]
    #[inline(always)]
    pub const fn ptr() -> *const fcfg1::RegisterBlock {
        Self::PTR
    }
}
impl Deref for FCFG1 {
    type Target = fcfg1::RegisterBlock;
    #[inline(always)]
    fn deref(&self) -> &Self::Target {
        unsafe { &*Self::PTR }
    }
}
impl core::fmt::Debug for FCFG1 {
    fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
        f.debug_struct("FCFG1").finish()
    }
}
#[doc = "Factory configuration area (FCFG1)"]
pub mod fcfg1;
#[doc = "DMA Crypto Core is a low power low gate count crypto core with DMA capability and local key storage."]
pub struct CRYPTO {
    _marker: PhantomData<*const ()>,
}
unsafe impl Send for CRYPTO {}
impl CRYPTO {
    #[doc = r"Pointer to the register block"]
    pub const PTR: *const crypto::RegisterBlock = 0x5802_4000 as *const _;
    #[doc = r"Return the pointer to the register block"]
    #[inline(always)]
    pub const fn ptr() -> *const crypto::RegisterBlock {
        Self::PTR
    }
}
impl Deref for CRYPTO {
    type Target = crypto::RegisterBlock;
    #[inline(always)]
    fn deref(&self) -> &Self::Target {
        unsafe { &*Self::PTR }
    }
}
impl core::fmt::Debug for CRYPTO {
    fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
        f.debug_struct("CRYPTO").finish()
    }
}
#[doc = "DMA Crypto Core is a low power low gate count crypto core with DMA capability and local key storage."]
pub mod crypto;
#[doc = "Integrated module which combines the Public Key Acceleration module, optional True Random Gnerator, optional interrupt controller and a standard bus interface"]
pub struct PKA {
    _marker: PhantomData<*const ()>,
}
unsafe impl Send for PKA {}
impl PKA {
    #[doc = r"Pointer to the register block"]
    pub const PTR: *const pka::RegisterBlock = 0x5802_5000 as *const _;
    #[doc = r"Return the pointer to the register block"]
    #[inline(always)]
    pub const fn ptr() -> *const pka::RegisterBlock {
        Self::PTR
    }
}
impl Deref for PKA {
    type Target = pka::RegisterBlock;
    #[inline(always)]
    fn deref(&self) -> &Self::Target {
        unsafe { &*Self::PTR }
    }
}
impl core::fmt::Debug for PKA {
    fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
        f.debug_struct("PKA").finish()
    }
}
#[doc = "Integrated module which combines the Public Key Acceleration module, optional True Random Gnerator, optional interrupt controller and a standard bus interface"]
pub mod pka;
#[doc = "Integrated module which includes the PKA K"]
pub struct PKA_INT {
    _marker: PhantomData<*const ()>,
}
unsafe impl Send for PKA_INT {}
impl PKA_INT {
    #[doc = r"Pointer to the register block"]
    pub const PTR: *const pka_int::RegisterBlock = 0x5802_7000 as *const _;
    #[doc = r"Return the pointer to the register block"]
    #[inline(always)]
    pub const fn ptr() -> *const pka_int::RegisterBlock {
        Self::PTR
    }
}
impl Deref for PKA_INT {
    type Target = pka_int::RegisterBlock;
    #[inline(always)]
    fn deref(&self) -> &Self::Target {
        unsafe { &*Self::PTR }
    }
}
impl core::fmt::Debug for PKA_INT {
    fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
        f.debug_struct("PKA_INT").finish()
    }
}
#[doc = "Integrated module which includes the PKA K"]
pub mod pka_int;
#[doc = "True Random Number Generator"]
pub struct TRNG {
    _marker: PhantomData<*const ()>,
}
unsafe impl Send for TRNG {}
impl TRNG {
    #[doc = r"Pointer to the register block"]
    pub const PTR: *const trng::RegisterBlock = 0x5802_8000 as *const _;
    #[doc = r"Return the pointer to the register block"]
    #[inline(always)]
    pub const fn ptr() -> *const trng::RegisterBlock {
        Self::PTR
    }
}
impl Deref for TRNG {
    type Target = trng::RegisterBlock;
    #[inline(always)]
    fn deref(&self) -> &Self::Target {
        unsafe { &*Self::PTR }
    }
}
impl core::fmt::Debug for TRNG {
    fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
        f.debug_struct("TRNG").finish()
    }
}
#[doc = "True Random Number Generator"]
pub mod trng;
#[doc = "Thor1M Flash sub-system registers, includes the NoWrapper Flash Memory Controller (NW), flash read path, and an integrated Efuse controller and EFUSEROM."]
pub struct FLASH {
    _marker: PhantomData<*const ()>,
}
unsafe impl Send for FLASH {}
impl FLASH {
    #[doc = r"Pointer to the register block"]
    pub const PTR: *const flash::RegisterBlock = 0x5803_0000 as *const _;
    #[doc = r"Return the pointer to the register block"]
    #[inline(always)]
    pub const fn ptr() -> *const flash::RegisterBlock {
        Self::PTR
    }
}
impl Deref for FLASH {
    type Target = flash::RegisterBlock;
    #[inline(always)]
    fn deref(&self) -> &Self::Target {
        unsafe { &*Self::PTR }
    }
}
impl core::fmt::Debug for FLASH {
    fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
        f.debug_struct("FLASH").finish()
    }
}
#[doc = "Thor1M Flash sub-system registers, includes the NoWrapper Flash Memory Controller (NW), flash read path, and an integrated Efuse controller and EFUSEROM."]
pub mod flash;
#[doc = "NVMNW"]
pub struct NVMNW {
    _marker: PhantomData<*const ()>,
}
unsafe impl Send for NVMNW {}
impl NVMNW {
    #[doc = r"Pointer to the register block"]
    pub const PTR: *const nvmnw::RegisterBlock = 0x5803_2000 as *const _;
    #[doc = r"Return the pointer to the register block"]
    #[inline(always)]
    pub const fn ptr() -> *const nvmnw::RegisterBlock {
        Self::PTR
    }
}
impl Deref for NVMNW {
    type Target = nvmnw::RegisterBlock;
    #[inline(always)]
    fn deref(&self) -> &Self::Target {
        unsafe { &*Self::PTR }
    }
}
impl core::fmt::Debug for NVMNW {
    fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
        f.debug_struct("NVMNW").finish()
    }
}
#[doc = "NVMNW"]
pub mod nvmnw;
#[doc = "General Purpose RAM"]
pub struct SRAM_MMR {
    _marker: PhantomData<*const ()>,
}
unsafe impl Send for SRAM_MMR {}
impl SRAM_MMR {
    #[doc = r"Pointer to the register block"]
    pub const PTR: *const sram_mmr::RegisterBlock = 0x5803_5000 as *const _;
    #[doc = r"Return the pointer to the register block"]
    #[inline(always)]
    pub const fn ptr() -> *const sram_mmr::RegisterBlock {
        Self::PTR
    }
}
impl Deref for SRAM_MMR {
    type Target = sram_mmr::RegisterBlock;
    #[inline(always)]
    fn deref(&self) -> &Self::Target {
        unsafe { &*Self::PTR }
    }
}
impl core::fmt::Debug for SRAM_MMR {
    fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
        f.debug_struct("SRAM_MMR").finish()
    }
}
#[doc = "General Purpose RAM"]
pub mod sram_mmr;
#[doc = "Power, Reset and Clock Management"]
pub struct PRCM {
    _marker: PhantomData<*const ()>,
}
unsafe impl Send for PRCM {}
impl PRCM {
    #[doc = r"Pointer to the register block"]
    pub const PTR: *const prcm::RegisterBlock = 0x5808_2000 as *const _;
    #[doc = r"Return the pointer to the register block"]
    #[inline(always)]
    pub const fn ptr() -> *const prcm::RegisterBlock {
        Self::PTR
    }
}
impl Deref for PRCM {
    type Target = prcm::RegisterBlock;
    #[inline(always)]
    fn deref(&self) -> &Self::Target {
        unsafe { &*Self::PTR }
    }
}
impl core::fmt::Debug for PRCM {
    fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
        f.debug_struct("PRCM").finish()
    }
}
#[doc = "Power, Reset and Clock Management"]
pub mod prcm;
#[doc = "This component control the Power Management controller residing in the AON domain. Note: This module is only supporting 32 bit Read Write access from MCU"]
pub struct AON_PMCTL {
    _marker: PhantomData<*const ()>,
}
unsafe impl Send for AON_PMCTL {}
impl AON_PMCTL {
    #[doc = r"Pointer to the register block"]
    pub const PTR: *const aon_pmctl::RegisterBlock = 0x5809_0000 as *const _;
    #[doc = r"Return the pointer to the register block"]
    #[inline(always)]
    pub const fn ptr() -> *const aon_pmctl::RegisterBlock {
        Self::PTR
    }
}
impl Deref for AON_PMCTL {
    type Target = aon_pmctl::RegisterBlock;
    #[inline(always)]
    fn deref(&self) -> &Self::Target {
        unsafe { &*Self::PTR }
    }
}
impl core::fmt::Debug for AON_PMCTL {
    fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
        f.debug_struct("AON_PMCTL").finish()
    }
}
#[doc = "This component control the Power Management controller residing in the AON domain. Note: This module is only supporting 32 bit Read Write access from MCU"]
pub mod aon_pmctl;
#[doc = "This component control the Real Time Clock residing in AON Note: This module is only supporting 32 bit ReadWrite access."]
pub struct AON_RTC {
    _marker: PhantomData<*const ()>,
}
unsafe impl Send for AON_RTC {}
impl AON_RTC {
    #[doc = r"Pointer to the register block"]
    pub const PTR: *const aon_rtc::RegisterBlock = 0x5809_2000 as *const _;
    #[doc = r"Return the pointer to the register block"]
    #[inline(always)]
    pub const fn ptr() -> *const aon_rtc::RegisterBlock {
        Self::PTR
    }
}
impl Deref for AON_RTC {
    type Target = aon_rtc::RegisterBlock;
    #[inline(always)]
    fn deref(&self) -> &Self::Target {
        unsafe { &*Self::PTR }
    }
}
impl core::fmt::Debug for AON_RTC {
    fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
        f.debug_struct("AON_RTC").finish()
    }
}
#[doc = "This component control the Real Time Clock residing in AON Note: This module is only supporting 32 bit ReadWrite access."]
pub mod aon_rtc;
#[doc = "AUX System Interface (AUX_SYSIF) is responsible for: - system resource requests, such as power supply, clock and, wakeup requests. - configuration of AUX peripheral operational rates for AUX_SPIM, AUX_MAC, AUX_ANAIF DAC state machine and AUX_TIMER01. - configuration of event synchronization rate for AUX_EVCTL:EVSTAT2 and AUX_EVCTL:EVSTAT3. - configuration of AUX_SCE wakeup vectors that trigger AUX_SCE execution from sleep. Peripheral operational rate for AUX modules mentioned above can either be: - SCE rate, which is configured in AON_PMCTL:AUXSCECLK. - AUX bus rate, which equals SCE rate or SCLK_HF divided by two when MCU domain is active or AUX operational mode is active. AUX_SYSIF also interfaces AON_RTC and AON_BATMON to enable read access to data and sub-second increment control of AON_RTC."]
pub struct AUX_SYSIF {
    _marker: PhantomData<*const ()>,
}
unsafe impl Send for AUX_SYSIF {}
impl AUX_SYSIF {
    #[doc = r"Pointer to the register block"]
    pub const PTR: *const aux_sysif::RegisterBlock = 0x580c_6000 as *const _;
    #[doc = r"Return the pointer to the register block"]
    #[inline(always)]
    pub const fn ptr() -> *const aux_sysif::RegisterBlock {
        Self::PTR
    }
}
impl Deref for AUX_SYSIF {
    type Target = aux_sysif::RegisterBlock;
    #[inline(always)]
    fn deref(&self) -> &Self::Target {
        unsafe { &*Self::PTR }
    }
}
impl core::fmt::Debug for AUX_SYSIF {
    fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
        f.debug_struct("AUX_SYSIF").finish()
    }
}
#[doc = "AUX System Interface (AUX_SYSIF) is responsible for: - system resource requests, such as power supply, clock and, wakeup requests. - configuration of AUX peripheral operational rates for AUX_SPIM, AUX_MAC, AUX_ANAIF DAC state machine and AUX_TIMER01. - configuration of event synchronization rate for AUX_EVCTL:EVSTAT2 and AUX_EVCTL:EVSTAT3. - configuration of AUX_SCE wakeup vectors that trigger AUX_SCE execution from sleep. Peripheral operational rate for AUX modules mentioned above can either be: - SCE rate, which is configured in AON_PMCTL:AUXSCECLK. - AUX bus rate, which equals SCE rate or SCLK_HF divided by two when MCU domain is active or AUX operational mode is active. AUX_SYSIF also interfaces AON_RTC and AON_BATMON to enable read access to data and sub-second increment control of AON_RTC."]
pub mod aux_sysif;
#[doc = "AUX Sensor Control Engine (AUX_SCE) is a RISC-style microprocessor with separate fetch and execution cycles. It is optimized for low power and simple operations. AUX_SCE code and data segments are stored in AUX_RAM. AON_PMCTL:AUXSCECLK sets the operational frequency."]
pub struct AUX_SCE {
    _marker: PhantomData<*const ()>,
}
unsafe impl Send for AUX_SCE {}
impl AUX_SCE {
    #[doc = r"Pointer to the register block"]
    pub const PTR: *const aux_sce::RegisterBlock = 0x580e_1000 as *const _;
    #[doc = r"Return the pointer to the register block"]
    #[inline(always)]
    pub const fn ptr() -> *const aux_sce::RegisterBlock {
        Self::PTR
    }
}
impl Deref for AUX_SCE {
    type Target = aux_sce::RegisterBlock;
    #[inline(always)]
    fn deref(&self) -> &Self::Target {
        unsafe { &*Self::PTR }
    }
}
impl core::fmt::Debug for AUX_SCE {
    fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
        f.debug_struct("AUX_SCE").finish()
    }
}
#[doc = "AUX Sensor Control Engine (AUX_SCE) is a RISC-style microprocessor with separate fetch and execution cycles. It is optimized for low power and simple operations. AUX_SCE code and data segments are stored in AUX_RAM. AON_PMCTL:AUXSCECLK sets the operational frequency."]
pub mod aux_sce;
#[doc = "Cortex-M's Instrumentation Trace Macrocell (ITM)"]
pub struct CPU_ITM {
    _marker: PhantomData<*const ()>,
}
unsafe impl Send for CPU_ITM {}
impl CPU_ITM {
    #[doc = r"Pointer to the register block"]
    pub const PTR: *const cpu_itm::RegisterBlock = 0xe000_0000 as *const _;
    #[doc = r"Return the pointer to the register block"]
    #[inline(always)]
    pub const fn ptr() -> *const cpu_itm::RegisterBlock {
        Self::PTR
    }
}
impl Deref for CPU_ITM {
    type Target = cpu_itm::RegisterBlock;
    #[inline(always)]
    fn deref(&self) -> &Self::Target {
        unsafe { &*Self::PTR }
    }
}
impl core::fmt::Debug for CPU_ITM {
    fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
        f.debug_struct("CPU_ITM").finish()
    }
}
#[doc = "Cortex-M's Instrumentation Trace Macrocell (ITM)"]
pub mod cpu_itm;
#[doc = "Cortex-M's Data watchpoint and Trace (DWT)"]
pub struct CPU_DWT {
    _marker: PhantomData<*const ()>,
}
unsafe impl Send for CPU_DWT {}
impl CPU_DWT {
    #[doc = r"Pointer to the register block"]
    pub const PTR: *const cpu_dwt::RegisterBlock = 0xe000_1000 as *const _;
    #[doc = r"Return the pointer to the register block"]
    #[inline(always)]
    pub const fn ptr() -> *const cpu_dwt::RegisterBlock {
        Self::PTR
    }
}
impl Deref for CPU_DWT {
    type Target = cpu_dwt::RegisterBlock;
    #[inline(always)]
    fn deref(&self) -> &Self::Target {
        unsafe { &*Self::PTR }
    }
}
impl core::fmt::Debug for CPU_DWT {
    fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
        f.debug_struct("CPU_DWT").finish()
    }
}
#[doc = "Cortex-M's Data watchpoint and Trace (DWT)"]
pub mod cpu_dwt;
#[doc = "Cortex-M's Flash Patch and Breakpoint (FPB)"]
pub struct CPU_FPB {
    _marker: PhantomData<*const ()>,
}
unsafe impl Send for CPU_FPB {}
impl CPU_FPB {
    #[doc = r"Pointer to the register block"]
    pub const PTR: *const cpu_fpb::RegisterBlock = 0xe000_2000 as *const _;
    #[doc = r"Return the pointer to the register block"]
    #[inline(always)]
    pub const fn ptr() -> *const cpu_fpb::RegisterBlock {
        Self::PTR
    }
}
impl Deref for CPU_FPB {
    type Target = cpu_fpb::RegisterBlock;
    #[inline(always)]
    fn deref(&self) -> &Self::Target {
        unsafe { &*Self::PTR }
    }
}
impl core::fmt::Debug for CPU_FPB {
    fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
        f.debug_struct("CPU_FPB").finish()
    }
}
#[doc = "Cortex-M's Flash Patch and Breakpoint (FPB)"]
pub mod cpu_fpb;
#[doc = "Cortex-M's Implementation Control Block (ICB)"]
pub struct CPU_ICB {
    _marker: PhantomData<*const ()>,
}
unsafe impl Send for CPU_ICB {}
impl CPU_ICB {
    #[doc = r"Pointer to the register block"]
    pub const PTR: *const cpu_icb::RegisterBlock = 0xe000_e000 as *const _;
    #[doc = r"Return the pointer to the register block"]
    #[inline(always)]
    pub const fn ptr() -> *const cpu_icb::RegisterBlock {
        Self::PTR
    }
}
impl Deref for CPU_ICB {
    type Target = cpu_icb::RegisterBlock;
    #[inline(always)]
    fn deref(&self) -> &Self::Target {
        unsafe { &*Self::PTR }
    }
}
impl core::fmt::Debug for CPU_ICB {
    fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
        f.debug_struct("CPU_ICB").finish()
    }
}
#[doc = "Cortex-M's Implementation Control Block (ICB)"]
pub mod cpu_icb;
#[doc = "Cortex-M's System Timer (SYSTICK)"]
pub struct CPU_SYSTICK {
    _marker: PhantomData<*const ()>,
}
unsafe impl Send for CPU_SYSTICK {}
impl CPU_SYSTICK {
    #[doc = r"Pointer to the register block"]
    pub const PTR: *const cpu_systick::RegisterBlock = 0xe000_e010 as *const _;
    #[doc = r"Return the pointer to the register block"]
    #[inline(always)]
    pub const fn ptr() -> *const cpu_systick::RegisterBlock {
        Self::PTR
    }
}
impl Deref for CPU_SYSTICK {
    type Target = cpu_systick::RegisterBlock;
    #[inline(always)]
    fn deref(&self) -> &Self::Target {
        unsafe { &*Self::PTR }
    }
}
impl core::fmt::Debug for CPU_SYSTICK {
    fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
        f.debug_struct("CPU_SYSTICK").finish()
    }
}
#[doc = "Cortex-M's System Timer (SYSTICK)"]
pub mod cpu_systick;
#[doc = "Cortex-M's Nested Vectored Interrupt Controller (NVIC)"]
pub struct CPU_NVIC {
    _marker: PhantomData<*const ()>,
}
unsafe impl Send for CPU_NVIC {}
impl CPU_NVIC {
    #[doc = r"Pointer to the register block"]
    pub const PTR: *const cpu_nvic::RegisterBlock = 0xe000_e100 as *const _;
    #[doc = r"Return the pointer to the register block"]
    #[inline(always)]
    pub const fn ptr() -> *const cpu_nvic::RegisterBlock {
        Self::PTR
    }
}
impl Deref for CPU_NVIC {
    type Target = cpu_nvic::RegisterBlock;
    #[inline(always)]
    fn deref(&self) -> &Self::Target {
        unsafe { &*Self::PTR }
    }
}
impl core::fmt::Debug for CPU_NVIC {
    fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
        f.debug_struct("CPU_NVIC").finish()
    }
}
#[doc = "Cortex-M's Nested Vectored Interrupt Controller (NVIC)"]
pub mod cpu_nvic;
#[doc = "Cortex-M's System Control Block (SCB)"]
pub struct CPU_SCB {
    _marker: PhantomData<*const ()>,
}
unsafe impl Send for CPU_SCB {}
impl CPU_SCB {
    #[doc = r"Pointer to the register block"]
    pub const PTR: *const cpu_scb::RegisterBlock = 0xe000_ed00 as *const _;
    #[doc = r"Return the pointer to the register block"]
    #[inline(always)]
    pub const fn ptr() -> *const cpu_scb::RegisterBlock {
        Self::PTR
    }
}
impl Deref for CPU_SCB {
    type Target = cpu_scb::RegisterBlock;
    #[inline(always)]
    fn deref(&self) -> &Self::Target {
        unsafe { &*Self::PTR }
    }
}
impl core::fmt::Debug for CPU_SCB {
    fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
        f.debug_struct("CPU_SCB").finish()
    }
}
#[doc = "Cortex-M's System Control Block (SCB)"]
pub mod cpu_scb;
#[doc = "Cortex-M's Memory Protection Unit (MPU)"]
pub struct CPU_MPU {
    _marker: PhantomData<*const ()>,
}
unsafe impl Send for CPU_MPU {}
impl CPU_MPU {
    #[doc = r"Pointer to the register block"]
    pub const PTR: *const cpu_mpu::RegisterBlock = 0xe000_ed90 as *const _;
    #[doc = r"Return the pointer to the register block"]
    #[inline(always)]
    pub const fn ptr() -> *const cpu_mpu::RegisterBlock {
        Self::PTR
    }
}
impl Deref for CPU_MPU {
    type Target = cpu_mpu::RegisterBlock;
    #[inline(always)]
    fn deref(&self) -> &Self::Target {
        unsafe { &*Self::PTR }
    }
}
impl core::fmt::Debug for CPU_MPU {
    fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
        f.debug_struct("CPU_MPU").finish()
    }
}
#[doc = "Cortex-M's Memory Protection Unit (MPU)"]
pub mod cpu_mpu;
#[doc = "Cortex-M's Security Attribution Unit (SAU)"]
pub struct CPU_SAU {
    _marker: PhantomData<*const ()>,
}
unsafe impl Send for CPU_SAU {}
impl CPU_SAU {
    #[doc = r"Pointer to the register block"]
    pub const PTR: *const cpu_sau::RegisterBlock = 0xe000_edd0 as *const _;
    #[doc = r"Return the pointer to the register block"]
    #[inline(always)]
    pub const fn ptr() -> *const cpu_sau::RegisterBlock {
        Self::PTR
    }
}
impl Deref for CPU_SAU {
    type Target = cpu_sau::RegisterBlock;
    #[inline(always)]
    fn deref(&self) -> &Self::Target {
        unsafe { &*Self::PTR }
    }
}
impl core::fmt::Debug for CPU_SAU {
    fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
        f.debug_struct("CPU_SAU").finish()
    }
}
#[doc = "Cortex-M's Security Attribution Unit (SAU)"]
pub mod cpu_sau;
#[doc = "Cortex-M's Debug Control Block"]
pub struct CPU_DCB {
    _marker: PhantomData<*const ()>,
}
unsafe impl Send for CPU_DCB {}
impl CPU_DCB {
    #[doc = r"Pointer to the register block"]
    pub const PTR: *const cpu_dcb::RegisterBlock = 0xe000_ede0 as *const _;
    #[doc = r"Return the pointer to the register block"]
    #[inline(always)]
    pub const fn ptr() -> *const cpu_dcb::RegisterBlock {
        Self::PTR
    }
}
impl Deref for CPU_DCB {
    type Target = cpu_dcb::RegisterBlock;
    #[inline(always)]
    fn deref(&self) -> &Self::Target {
        unsafe { &*Self::PTR }
    }
}
impl core::fmt::Debug for CPU_DCB {
    fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
        f.debug_struct("CPU_DCB").finish()
    }
}
#[doc = "Cortex-M's Debug Control Block"]
pub mod cpu_dcb;
#[doc = "Cortex-M's Software Interrupt Generator (SIG)"]
pub struct CPU_SIG {
    _marker: PhantomData<*const ()>,
}
unsafe impl Send for CPU_SIG {}
impl CPU_SIG {
    #[doc = r"Pointer to the register block"]
    pub const PTR: *const cpu_sig::RegisterBlock = 0xe000_ef00 as *const _;
    #[doc = r"Return the pointer to the register block"]
    #[inline(always)]
    pub const fn ptr() -> *const cpu_sig::RegisterBlock {
        Self::PTR
    }
}
impl Deref for CPU_SIG {
    type Target = cpu_sig::RegisterBlock;
    #[inline(always)]
    fn deref(&self) -> &Self::Target {
        unsafe { &*Self::PTR }
    }
}
impl core::fmt::Debug for CPU_SIG {
    fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
        f.debug_struct("CPU_SIG").finish()
    }
}
#[doc = "Cortex-M's Software Interrupt Generator (SIG)"]
pub mod cpu_sig;
#[doc = "Cortex-M's Floating Point Unit (FPU)"]
pub struct CPU_FPU {
    _marker: PhantomData<*const ()>,
}
unsafe impl Send for CPU_FPU {}
impl CPU_FPU {
    #[doc = r"Pointer to the register block"]
    pub const PTR: *const cpu_fpu::RegisterBlock = 0xe000_ef30 as *const _;
    #[doc = r"Return the pointer to the register block"]
    #[inline(always)]
    pub const fn ptr() -> *const cpu_fpu::RegisterBlock {
        Self::PTR
    }
}
impl Deref for CPU_FPU {
    type Target = cpu_fpu::RegisterBlock;
    #[inline(always)]
    fn deref(&self) -> &Self::Target {
        unsafe { &*Self::PTR }
    }
}
impl core::fmt::Debug for CPU_FPU {
    fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
        f.debug_struct("CPU_FPU").finish()
    }
}
#[doc = "Cortex-M's Floating Point Unit (FPU)"]
pub mod cpu_fpu;
#[doc = "Cortex-M's Trace Port Interface Unit (TPIU)"]
pub struct CPU_TPIU {
    _marker: PhantomData<*const ()>,
}
unsafe impl Send for CPU_TPIU {}
impl CPU_TPIU {
    #[doc = r"Pointer to the register block"]
    pub const PTR: *const cpu_tpiu::RegisterBlock = 0xe004_0000 as *const _;
    #[doc = r"Return the pointer to the register block"]
    #[inline(always)]
    pub const fn ptr() -> *const cpu_tpiu::RegisterBlock {
        Self::PTR
    }
}
impl Deref for CPU_TPIU {
    type Target = cpu_tpiu::RegisterBlock;
    #[inline(always)]
    fn deref(&self) -> &Self::Target {
        unsafe { &*Self::PTR }
    }
}
impl core::fmt::Debug for CPU_TPIU {
    fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
        f.debug_struct("CPU_TPIU").finish()
    }
}
#[doc = "Cortex-M's Trace Port Interface Unit (TPIU)"]
pub mod cpu_tpiu;
#[no_mangle]
static mut DEVICE_PERIPHERALS: bool = false;
#[doc = r" All the peripherals."]
#[allow(non_snake_case)]
pub struct Peripherals {
    #[doc = "AUX_ADI4"]
    pub AUX_ADI4: AUX_ADI4,
    #[doc = "AUX_DDI0_OSC"]
    pub AUX_DDI0_OSC: AUX_DDI0_OSC,
    #[doc = "SPI0"]
    pub SPI0: SPI0,
    #[doc = "UART0"]
    pub UART0: UART0,
    #[doc = "I2C0"]
    pub I2C0: I2C0,
    #[doc = "SPI1"]
    pub SPI1: SPI1,
    #[doc = "SPI2"]
    pub SPI2: SPI2,
    #[doc = "SPI3"]
    pub SPI3: SPI3,
    #[doc = "UART1"]
    pub UART1: UART1,
    #[doc = "UART2"]
    pub UART2: UART2,
    #[doc = "UART3"]
    pub UART3: UART3,
    #[doc = "GPT0"]
    pub GPT0: GPT0,
    #[doc = "GPT1"]
    pub GPT1: GPT1,
    #[doc = "GPT2"]
    pub GPT2: GPT2,
    #[doc = "GPT3"]
    pub GPT3: GPT3,
    #[doc = "UDMA0"]
    pub UDMA0: UDMA0,
    #[doc = "I2S0"]
    pub I2S0: I2S0,
    #[doc = "GPIO"]
    pub GPIO: GPIO,
    #[doc = "I2C1"]
    pub I2C1: I2C1,
    #[doc = "VIMS"]
    pub VIMS: VIMS,
    #[doc = "RFC_PWR"]
    pub RFC_PWR: RFC_PWR,
    #[doc = "RFC_DBELL"]
    pub RFC_DBELL: RFC_DBELL,
    #[doc = "RFC_RAT"]
    pub RFC_RAT: RFC_RAT,
    #[doc = "WDT"]
    pub WDT: WDT,
    #[doc = "IOC"]
    pub IOC: IOC,
    #[doc = "EVENT"]
    pub EVENT: EVENT,
    #[doc = "SMPH"]
    pub SMPH: SMPH,
    #[doc = "AON_EVENT"]
    pub AON_EVENT: AON_EVENT,
    #[doc = "AON_IOC"]
    pub AON_IOC: AON_IOC,
    #[doc = "AON_BATMON"]
    pub AON_BATMON: AON_BATMON,
    #[doc = "AUX_SPIM"]
    pub AUX_SPIM: AUX_SPIM,
    #[doc = "AUX_MAC"]
    pub AUX_MAC: AUX_MAC,
    #[doc = "AUX_TIMER2"]
    pub AUX_TIMER2: AUX_TIMER2,
    #[doc = "AUX_TDC"]
    pub AUX_TDC: AUX_TDC,
    #[doc = "AUX_EVCTL"]
    pub AUX_EVCTL: AUX_EVCTL,
    #[doc = "AUX_TIMER01"]
    pub AUX_TIMER01: AUX_TIMER01,
    #[doc = "AUX_SMPH"]
    pub AUX_SMPH: AUX_SMPH,
    #[doc = "AUX_ANAIF"]
    pub AUX_ANAIF: AUX_ANAIF,
    #[doc = "AUX_AIODIO0"]
    pub AUX_AIODIO0: AUX_AIODIO0,
    #[doc = "AUX_AIODIO1"]
    pub AUX_AIODIO1: AUX_AIODIO1,
    #[doc = "AUX_AIODIO2"]
    pub AUX_AIODIO2: AUX_AIODIO2,
    #[doc = "AUX_AIODIO3"]
    pub AUX_AIODIO3: AUX_AIODIO3,
    #[doc = "CCFG"]
    pub CCFG: CCFG,
    #[doc = "FCFG1"]
    pub FCFG1: FCFG1,
    #[doc = "CRYPTO"]
    pub CRYPTO: CRYPTO,
    #[doc = "PKA"]
    pub PKA: PKA,
    #[doc = "PKA_INT"]
    pub PKA_INT: PKA_INT,
    #[doc = "TRNG"]
    pub TRNG: TRNG,
    #[doc = "FLASH"]
    pub FLASH: FLASH,
    #[doc = "NVMNW"]
    pub NVMNW: NVMNW,
    #[doc = "SRAM_MMR"]
    pub SRAM_MMR: SRAM_MMR,
    #[doc = "PRCM"]
    pub PRCM: PRCM,
    #[doc = "AON_PMCTL"]
    pub AON_PMCTL: AON_PMCTL,
    #[doc = "AON_RTC"]
    pub AON_RTC: AON_RTC,
    #[doc = "AUX_SYSIF"]
    pub AUX_SYSIF: AUX_SYSIF,
    #[doc = "AUX_SCE"]
    pub AUX_SCE: AUX_SCE,
    #[doc = "CPU_ITM"]
    pub CPU_ITM: CPU_ITM,
    #[doc = "CPU_DWT"]
    pub CPU_DWT: CPU_DWT,
    #[doc = "CPU_FPB"]
    pub CPU_FPB: CPU_FPB,
    #[doc = "CPU_ICB"]
    pub CPU_ICB: CPU_ICB,
    #[doc = "CPU_SYSTICK"]
    pub CPU_SYSTICK: CPU_SYSTICK,
    #[doc = "CPU_NVIC"]
    pub CPU_NVIC: CPU_NVIC,
    #[doc = "CPU_SCB"]
    pub CPU_SCB: CPU_SCB,
    #[doc = "CPU_MPU"]
    pub CPU_MPU: CPU_MPU,
    #[doc = "CPU_SAU"]
    pub CPU_SAU: CPU_SAU,
    #[doc = "CPU_DCB"]
    pub CPU_DCB: CPU_DCB,
    #[doc = "CPU_SIG"]
    pub CPU_SIG: CPU_SIG,
    #[doc = "CPU_FPU"]
    pub CPU_FPU: CPU_FPU,
    #[doc = "CPU_TPIU"]
    pub CPU_TPIU: CPU_TPIU,
}
impl Peripherals {
    #[doc = r" Returns all the peripherals *once*."]
    #[cfg(feature = "critical-section")]
    #[inline]
    pub fn take() -> Option<Self> {
        critical_section::with(|_| {
            if unsafe { DEVICE_PERIPHERALS } {
                return None;
            }
            Some(unsafe { Peripherals::steal() })
        })
    }
    #[doc = r" Unchecked version of `Peripherals::take`."]
    #[doc = r""]
    #[doc = r" # Safety"]
    #[doc = r""]
    #[doc = r" Each of the returned peripherals must be used at most once."]
    #[inline]
    pub unsafe fn steal() -> Self {
        DEVICE_PERIPHERALS = true;
        Peripherals {
            AUX_ADI4: AUX_ADI4 {
                _marker: PhantomData,
            },
            AUX_DDI0_OSC: AUX_DDI0_OSC {
                _marker: PhantomData,
            },
            SPI0: SPI0 {
                _marker: PhantomData,
            },
            UART0: UART0 {
                _marker: PhantomData,
            },
            I2C0: I2C0 {
                _marker: PhantomData,
            },
            SPI1: SPI1 {
                _marker: PhantomData,
            },
            SPI2: SPI2 {
                _marker: PhantomData,
            },
            SPI3: SPI3 {
                _marker: PhantomData,
            },
            UART1: UART1 {
                _marker: PhantomData,
            },
            UART2: UART2 {
                _marker: PhantomData,
            },
            UART3: UART3 {
                _marker: PhantomData,
            },
            GPT0: GPT0 {
                _marker: PhantomData,
            },
            GPT1: GPT1 {
                _marker: PhantomData,
            },
            GPT2: GPT2 {
                _marker: PhantomData,
            },
            GPT3: GPT3 {
                _marker: PhantomData,
            },
            UDMA0: UDMA0 {
                _marker: PhantomData,
            },
            I2S0: I2S0 {
                _marker: PhantomData,
            },
            GPIO: GPIO {
                _marker: PhantomData,
            },
            I2C1: I2C1 {
                _marker: PhantomData,
            },
            VIMS: VIMS {
                _marker: PhantomData,
            },
            RFC_PWR: RFC_PWR {
                _marker: PhantomData,
            },
            RFC_DBELL: RFC_DBELL {
                _marker: PhantomData,
            },
            RFC_RAT: RFC_RAT {
                _marker: PhantomData,
            },
            WDT: WDT {
                _marker: PhantomData,
            },
            IOC: IOC {
                _marker: PhantomData,
            },
            EVENT: EVENT {
                _marker: PhantomData,
            },
            SMPH: SMPH {
                _marker: PhantomData,
            },
            AON_EVENT: AON_EVENT {
                _marker: PhantomData,
            },
            AON_IOC: AON_IOC {
                _marker: PhantomData,
            },
            AON_BATMON: AON_BATMON {
                _marker: PhantomData,
            },
            AUX_SPIM: AUX_SPIM {
                _marker: PhantomData,
            },
            AUX_MAC: AUX_MAC {
                _marker: PhantomData,
            },
            AUX_TIMER2: AUX_TIMER2 {
                _marker: PhantomData,
            },
            AUX_TDC: AUX_TDC {
                _marker: PhantomData,
            },
            AUX_EVCTL: AUX_EVCTL {
                _marker: PhantomData,
            },
            AUX_TIMER01: AUX_TIMER01 {
                _marker: PhantomData,
            },
            AUX_SMPH: AUX_SMPH {
                _marker: PhantomData,
            },
            AUX_ANAIF: AUX_ANAIF {
                _marker: PhantomData,
            },
            AUX_AIODIO0: AUX_AIODIO0 {
                _marker: PhantomData,
            },
            AUX_AIODIO1: AUX_AIODIO1 {
                _marker: PhantomData,
            },
            AUX_AIODIO2: AUX_AIODIO2 {
                _marker: PhantomData,
            },
            AUX_AIODIO3: AUX_AIODIO3 {
                _marker: PhantomData,
            },
            CCFG: CCFG {
                _marker: PhantomData,
            },
            FCFG1: FCFG1 {
                _marker: PhantomData,
            },
            CRYPTO: CRYPTO {
                _marker: PhantomData,
            },
            PKA: PKA {
                _marker: PhantomData,
            },
            PKA_INT: PKA_INT {
                _marker: PhantomData,
            },
            TRNG: TRNG {
                _marker: PhantomData,
            },
            FLASH: FLASH {
                _marker: PhantomData,
            },
            NVMNW: NVMNW {
                _marker: PhantomData,
            },
            SRAM_MMR: SRAM_MMR {
                _marker: PhantomData,
            },
            PRCM: PRCM {
                _marker: PhantomData,
            },
            AON_PMCTL: AON_PMCTL {
                _marker: PhantomData,
            },
            AON_RTC: AON_RTC {
                _marker: PhantomData,
            },
            AUX_SYSIF: AUX_SYSIF {
                _marker: PhantomData,
            },
            AUX_SCE: AUX_SCE {
                _marker: PhantomData,
            },
            CPU_ITM: CPU_ITM {
                _marker: PhantomData,
            },
            CPU_DWT: CPU_DWT {
                _marker: PhantomData,
            },
            CPU_FPB: CPU_FPB {
                _marker: PhantomData,
            },
            CPU_ICB: CPU_ICB {
                _marker: PhantomData,
            },
            CPU_SYSTICK: CPU_SYSTICK {
                _marker: PhantomData,
            },
            CPU_NVIC: CPU_NVIC {
                _marker: PhantomData,
            },
            CPU_SCB: CPU_SCB {
                _marker: PhantomData,
            },
            CPU_MPU: CPU_MPU {
                _marker: PhantomData,
            },
            CPU_SAU: CPU_SAU {
                _marker: PhantomData,
            },
            CPU_DCB: CPU_DCB {
                _marker: PhantomData,
            },
            CPU_SIG: CPU_SIG {
                _marker: PhantomData,
            },
            CPU_FPU: CPU_FPU {
                _marker: PhantomData,
            },
            CPU_TPIU: CPU_TPIU {
                _marker: PhantomData,
            },
        }
    }
}
